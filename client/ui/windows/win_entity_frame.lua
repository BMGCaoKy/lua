---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by work.
--- DateTime: 2019/10/23 15:23
---
local keyBtn = { "tray", "candestroy", "openEvent" }
local keyEvent = {}
local extendType = {
    Mixture = { exp = {}, common = {} },
}
local converterID = {}
local IS_OPEN = false
local allEvent = {}

function M:init()
    WinBase.init(self, "EntityFrame.json")

    self.actorWnd = self:child("EntityFrame-Content-Actor")
    self.imageWnd = self:child("EntityFrame-Content-Image")
    self.expandContent = self:child("EntityFrame-Expand-Content")
    self.btnContent = self:child("EntityFrame-Btn")
    self.btnContainer = UIMgr:new_widget("grid_view")
    self.btnContainer:invoke("INIT_CONFIG", 5, 5, 2)
    self.btnContainer:invoke("ITEM_ALIGNMENT", 1)
    self.btnContainer:invoke("AUTO_COLUMN", false)
    self.btnContainer:invoke("MOVE_ABLE", false)
    self.btnContent:AddChildWindow(self.btnContainer)

    self.expandContainer = self:child("EntityFrame-Expand")
    self.containerShow = self:child("EntityFrame-Expand-Text")
    self.addContainerBtn = self:child("EntityFrame-Expand-Btn")

    Lib.subscribeEvent(Event.EVENT_PLAYER_ITEM_MODIFY, function()
        if not IS_OPEN then
            return
        end
        self:onOpen(self.curCell, self.cfg, self.eventKey, self.regId)
    end)
end

function M:onOpen(cell, cfg, key, regId)
    IS_OPEN = true
    self.cfg = cfg
    self.canUnwield = cfg.canUnwield
    self.eventKey = key
    self.regId = regId
    self:resetContent()
    local item = cell and cell:data("item")
    if not item or item:null() then
        self.expandContainer:SetVisible(false)
        return
    end
    self.curCell = cell
    self:initMainContent(item)
    self:updateCapacity(cfg.capacityCfg, item)
end

function M:onClose()
    IS_OPEN = false
    for _, close in pairs(allEvent) do
        close()
    end
end

function M:updateCapacity(cfg, item)
    self.expandContainer:SetVisible(cfg ~= false)
    if not cfg or not cfg.equipTray then
        return
    end
    local types = item:tray_type()
    local tray = nil
    for tid, _ in pairs(types) do
        if Define.TRAY_TYPE_CLASS[tid] == Define.TRAY_CLASS_EQUIP then
            tray = tid
            goto continue
        end
    end
    if not tray then
        self.expandContainer:SetVisible(false)
        return
    end
    :: continue ::
    local ret = Me:tray():query_trays(tray)
    local residue, total = 0, 0
    for _, element in pairs(ret) do
        local _tray = element.tray
        total = total + _tray:capacity()
        residue = residue + (_tray:capacity() - _tray:avail_capacity())
    end
    self.containerShow:SetText(string.format("%d/%d", residue, total))
    self:unsubscribe(self.addContainerBtn)
    self:subscribe(self.addContainerBtn, UIEvent.EventButtonClick, function()
        Me:doCallBack("backpackDisplay", self.eventKey, self.regId, { tray = tray })
    end)
end

function M:resetContent()
    self.actorWnd:SetActor1("")
    self.imageWnd:SetImage("")
    self.expandContent:CleanupChildren()
    self.btnContainer:invoke("CLEAN")
end

function M:initMainContent(item)
    local cfg = item:cfg()
    if cfg.showActor then
        self.actorWnd:SetActorScale(0.8)
        self.actorWnd:SetActor1(cfg.showActor, "idle")
    else
        local pixel = self:child("EntityFrame-Content"):GetPixelSize()
        self.imageWnd:SetImage(item:icon())
        self.imageWnd:SetArea({ 0, 0 }, { 0, 0 }, { 0, pixel.y * 0.55 }, { 0, pixel.y * 0.55 })
    end
    if cfg.extendDesc then
        self:initExtendContent(cfg.extendDesc, cfg, item)
    end
    self:initBtn(item)
end

extendType.Mixture.exp = function(wnd, info, extendCfg)
    --访问服务器获得宠物经验
    local count = wnd:GetChildCount()
    local property = GUIWindowManager.instance:CreateGUIWindow1("Layout", "Entity-Property-" .. count)
    property:SetArea({ 0, 0 }, { count * (1 / 3), 0 }, { 1, 0 }, { 1 / 3, 0 })
    property:SetBackgroundColor((count + 1) % 2 == 1 and { 187 / 255, 146 / 255, 110 / 255, 1 } or { 182 / 255, 129 / 255, 102 / 255, 1 })
    local sliderBg = GUIWindowManager.instance:CreateGUIWindow1("Layout", "Entity-Property-Slider-Bg-" .. count)
    sliderBg:SetArea({ 0, 0 }, { 0, 0 }, { 0.8, 0 }, { 0.6, 0 })
    sliderBg:SetProperty("StretchType", "NineGrid")
    sliderBg:SetProperty("StretchOffset", "5 5 5 5")
    sliderBg:SetHorizontalAlignment(1)
    sliderBg:SetVerticalAlignment(1)
    sliderBg:SetBackImage("set:backpack_display.json image:exp_progressbar_normal.png")
    property:AddChildWindow(sliderBg)
    local slider = GUIWindowManager.instance:CreateGUIWindow1("Slider", "Entity-Slider-" .. count)
    slider:SetArea({ 0, 0 }, { 0, 0 }, { 0.97, 0 }, { 0.6, 0 })
    slider:SetProperty("StretchType", "NineGrid")
    slider:SetProperty("StretchOffset", "5 5 5 5")
    slider:SetHorizontalAlignment(1)
    slider:SetVerticalAlignment(1)
    slider:SetProgressImage("set:backpack_display.json image:exp_progresbar_push.png")
    local exp, levelUpExp = info.exp, info.levelUpExp
    slider:SetProgress((exp == 0 or levelUpExp == 0) and 0 or (exp / levelUpExp))
    sliderBg:AddChildWindow(slider)
    local name = GUIWindowManager.instance:CreateGUIWindow1("StaticText", "Entity-Slider-Name-" .. count)
    name:SetArea({ 0.05, 0 }, { 0, 0 }, { 0.5, 0 }, { 1, 0 })
    name:SetVerticalAlignment(1)
    name:SetTextVertAlign(1)
    name:SetText(Lang:toText(extendCfg.langKey))
    name:SetTextBoader({ 0 / 255, 51 / 255, 30 / 255, 1 })
    sliderBg:AddChildWindow(name)
    local progress = GUIWindowManager.instance:CreateGUIWindow1("StaticText", "Entity-Slider-Progress-" .. count)
    progress:SetArea({ -0.05, 0 }, { 0, 0 }, { 0.5, 0 }, { 1, 0 })
    progress:SetVerticalAlignment(1)
    progress:SetHorizontalAlignment(2)
    progress:SetTextVertAlign(1)
    progress:SetTextHorzAlign(2)
    progress:SetText(Lang:toText({ "entity.slider.progress", Lib.switchNum(exp), Lib.switchNum(levelUpExp), ((exp == 0 or levelUpExp == 0) and 0 or string.format("%.2f", (exp / levelUpExp))) * 100 }))
    progress:SetTextBoader({ 0 / 255, 51 / 255, 30 / 255, 1 })
    sliderBg:AddChildWindow(progress)
    wnd:AddChildWindow(property)
end

extendType.Mixture.common = function(wnd, info, extendCfg, cfg)
    --访问服务器获取宠物的基本属性值
    local count = wnd:GetChildCount()
    local property = GUIWindowManager.instance:CreateGUIWindow1("Layout", "Item-Property-" .. count)
    property:SetArea({ 0, 0 }, { count * (1 / 3), 0 }, { 1, 0 }, { 1 / 3, 0 })
    property:SetBackgroundColor((count + 1) % 2 == 1 and { 187 / 255, 146 / 255, 110 / 255, 1 } or { 182 / 255, 129 / 255, 102 / 255, 1 })
    local proName = GUIWindowManager.instance:CreateGUIWindow1("StaticText", "Item-Property-Name-" .. count)
    proName:SetArea({ 0.1, 0 }, { 0, 0 }, { 0, 0 }, { 1, 0 })
    proName:SetTextVertAlign(1)
    proName:SetText(Lang:toText(extendCfg.langKey))
    proName:SetProperty("Font", "HT16")
    proName:SetTextColor({ 255 / 255, 233 / 255, 186 / 255, 1 })
    proName:SetProperty("TextBorder", "true")
    proName:SetProperty("TextRenderOffset", "0 -5")
    proName:SetTextBoader({ 119 / 255, 30 / 255, 21 / 255, 1 })
    property:AddChildWindow(proName)
    local icon = GUIWindowManager.instance:CreateGUIWindow1("StaticImage", "Item-Property-Icon-" .. count)
    icon:SetArea({ 0.45, 0 }, { 0, 0 }, { 0, 30 }, { 0, 30 })
    icon:SetVerticalAlignment(1)
    icon:SetImage(ResLoader:loadImage(cfg, extendCfg.icon))
    property:AddChildWindow(icon)
    local value = GUIWindowManager.instance:CreateGUIWindow1("StaticText", "Item-Property-Value-" .. count)
    value:SetArea({ 0.75, 0 }, { 0, 0 }, { 0, 0 }, { 1, 0 })
    value:SetText(info and (extendCfg.valueLang and Lang:toText({ extendCfg.valueLang, info }) or info) or "")
    value:SetTextVertAlign(1)
    value:SetProperty("Font", "HT14")
    value:SetProperty("TextBorder", "true")
    value:SetProperty("TextRenderOffset", "0 -5")
    value:SetTextBoader({ 119 / 255, 30 / 255, 21 / 255, 1 })
    property:AddChildWindow(value)
    wnd:AddChildWindow(property)
end

converterID.pet = function(item, key)
    if not key then
        return
    end
    local data = Me:data("pet")
    local pet = data[item:getVar(key)]
    return pet
end

function M:initExtendContent(extendCfg, cfg, item)
    local function func(info)
        self.expandContent:CleanupChildren()
        local _type = extendCfg.type
        local extend = _type and extendType[_type]
        for i, values in pairs(extendCfg.value or {}) do
            local proc = values.funcKey and extend[values.funcKey]
            if type(proc) == "function" and info.values[i] then
                proc(self.expandContent, info.values[i], values, cfg)
            end
        end
    end
    local objID
    local entity = extendCfg.entity
    if entity then
        local idProc = converterID[entity.key]
        if idProc then
            objID = idProc(item, entity.value)
        end
    end
    Me:sendPacket({
        pid = "QuerySimpleView",
        objID = objID  -- 拿到item对应pet进行查看信息
    }, function(ret)
        if ret and next(ret) then
            func(ret)
        end
    end)
end

local function createBtn(text, image, boaderColor)
    local btn = GUIWindowManager.instance:CreateGUIWindow1("Button", "Item-Frame-Btn-" .. text)
    btn:SetWidth({ 0.5, -20 })
    btn:SetHeight({ 1, 0 })
    btn:SetNormalImage(image)
    btn:SetPushedImage(image)
    btn:SetProperty("StretchType", "NineGrid")
    btn:SetProperty("StretchOffset", "70 90 0 0")
    local btnName = GUIWindowManager.instance:CreateGUIWindow1("StaticText", "Item-Frame-Name-" .. text)
    btnName:SetArea({ 0, 0 }, { 0, 0 }, { 1, 0 }, { 1, 0 })
    btnName:SetProperty("Font", "HT18")
    btnName:SetText(Lang:toText(text))
    btnName:SetTextHorzAlign(1)
    btnName:SetTextVertAlign(1)
    btnName:SetTextColor({ 217 / 255, 255 / 255, 253 / 255, 1 })
    btnName:SetProperty("TextBorder", true)
    btnName:SetTextBoader(boaderColor or { 0 / 255, 34 / 255, 96 / 255, 1 })
    btn:AddChildWindow(btnName)
    return btn
end

local function unifyProc(self, btn, proc)
    if not IS_OPEN then
        return
    end
    allEvent[#allEvent + 1] = self:subscribe(btn, UIEvent.EventButtonClick, function()
        -- self:unsubscribe(btn)
        -- World.Timer(20, function()
        --     if btn then
        --         unifyProc(self, btn, proc)
        --     end
        -- end)
        if proc then
            proc()
        end
    end)
end

local function canEquipTrayTid(item, curTid)
    local types = item:tray_type()
    local _tid, slot
    for tid, _ in pairs(types) do
        local ret = Me:tray():query_trays(tid)
        for _, element in pairs(ret) do
            local _tray = element.tray
            if Define.TRAY_TYPE_CLASS[_tray:type()] == Define.TRAY_TYPE_CLASS[curTid] then
                break
            end
            _tid = element.tid
            slot = _tray:find_free() or _tray:capacity()
            return _tid, slot
        end
    end
end

--keyEvent.openEvent = function(self, params)
--    local btn = createBtn("item.frame.open.btn", "set:new_gui_treasurebox.json image:blue_btn_bg.png")
--    -- 进行不同btn样试定义
--    local func
--    if params then
--        func = function()
--            Me:sendTrigger(Me, params, Me)
--        end
--    end
--    unifyProc(self, btn, func)
--    return btn
--end

keyEvent.candestroy = function(self, _, item)
    local btn = createBtn("item.frame.destroy.btn", "set:new_gui_treasurebox.json image:red_btn_bg.png")
    -- 进行物品销毁
    local tid, slot = item:tid(), item:slot()
    local affirmUiCfg = self.cfg.affirmUiCfg
    local function func()
        local callBack = function(key)
            if key == "yes" then
                Me:sendPacket({ pid = "DeleteItem", objID = Me.objID, bag = tid, slot = slot })
            end
        end
        local data = {
            uiCfg = affirmUiCfg,
            buttonType = 2,
            content = "entity.frame.confirm.candestroy",
            yesKey = "entity.frame.confirm.yes",
            noKey = "entity.frame.confirm.no",
            callBack = callBack,
            textArgs = {},
            showMask = true
        }
        if affirmUiCfg then
            Lib.emitEvent(Event.EVENT_SHOW_NOTICE, data)
        else
            callBack("key")
        end
    end
    unifyProc(self, btn, func)
    return btn
end

keyEvent.tray = function(self, _, item)
    -- 进行物品的装备与卸下
    local equip = true
    local tid, slot = item:tid(), item:slot()
    local tray = Me:tray():fetch_tray(tid)
    local trayType = tray:type()
    local equipTid, equipSlot = canEquipTrayTid(item, trayType)
    if Define.TRAY_TYPE_CLASS[trayType] == Define.TRAY_CLASS_BAG then
        equip = true
    elseif Define.TRAY_TYPE_CLASS[trayType] == Define.TRAY_CLASS_EQUIP then
        equip = false
    end
    local btn = createBtn(equip and "item.frame.equip.btn" or "item.frame.unequip.btn", "set:new_gui_treasurebox.json image:blue_btn_bg.png")
    if not equipTid or not equipSlot then
        return btn
    end
    local function func()
        Me:switchItem(tid, slot, equipTid, equipSlot, function(ret)
            if ret then
                Lib.emitEvent(Event.EVENT_BACKPACK_DISPLAY_RECORD, equipTid, equipSlot)
            end
        end)
    end
    if equip or self.canUnwield then
        unifyProc(self, btn, func)
    end
    return btn
end

function M:initBtn(item)
    self.btnContainer:invoke("CLEAN")
    local cfg = item:cfg()
    local count = 0
    for _, key in ipairs(keyBtn) do
        local ret = cfg[key]
        if ret then
            local proc = keyEvent[key]
            if proc and type(proc) == "function" then
                local btn = proc(self, ret, item)
                count = count + 1
                self.btnContainer:invoke("INIT_CONFIG", 5, 5, count)
                self.btnContainer:invoke("ITEM", btn)
            end
        end
    end
end

return M