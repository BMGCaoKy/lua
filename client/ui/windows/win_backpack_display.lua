---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by work.
--- DateTime: 2019/10/9 15:37
---
local frameDesc = {}
local function getCell()
    local cell = UIMgr:new_widget("cell")
    return cell
end
function M:init()
    WinBase.init(self, "BackpackDisplay.json")

    self.tab_layout = self:child("BackpackDisplay-Tab")
    self.tab = UIMgr:new_widget("tab", "Left", 10)
    self.tab:invoke("AREA", { 0, 0 }, { 0, 50 }, { 1, 0 }, { 1, -50 })
    self.tab:invoke("BTN_SIZE", { 1, 0 }, { 0, 78 })
    self.tab:invoke("BTN_STRETCH", "60 60 0 0")
    self.tab:invoke("BTN_IMAGE", "set:backpack_display.json image:tab_normal.png", "set:backpack_display.json image:tab_push.png")
    self.tab_layout:AddChildWindow(self.tab)
    self.mainContent = self:child("BackpackDisplay-Main-Content")
    self.desc = self:child("BackpackDisplay-Desc")
    self.titleName = self:child("BackpackDisplay-Title-Name")
    self.titleName:SetText(Lang:toText("gui_backpack_display_title_name"))
    self.closeBtn = self:child("BackpackDisplay-Close")
    self:subscribe(self.closeBtn, UIEvent.EventButtonClick, function()
        self:closeSelf()
    end)
    self.contentContainer = self:child("BackpackDisplay-Content-Container")
    self.gridView = UIMgr:new_widget("grid_view")
    self.gridView:invoke("AUTO_COLUMN", false)
    self.gridView:invoke("MOVE_ABLE", false)
    self.gridView:invoke("INIT_CONFIG", 10, 10, 3)
    self.contentContainer:AddChildWindow(self.gridView)

    self.topContainer = self:child("BackpackDisplay-Container-Top")
    self.expandContainerBtn = self:child("BackpackDisplay-Expand-Btn")
    self.expandContainerShow = self:child("BackpackDisplay-Expand-Text")

    self.pageDesc = self:child("BackpackDisplay-PageTuring-Desc")
    self.pageTuringLast = self:child("BackpackDisplay-PageTuring-Last")
	self.emptyFrame = self:child("BackpackDisplay-empty-frame")
    self:subscribe(self.pageTuringLast, UIEvent.EventButtonClick, function()
        if self.page == 1 then
            return
        end
        self.page = self.page - 1
        self:updateCells(true)
        self:updatePageDesc()
    end)
    self.pageTuringNext = self:child("BackpackDisplay-PageTuring-Next")
    self:subscribe(self.pageTuringNext, UIEvent.EventButtonClick, function()
        if self.page == self.maxPage then
            return
        end
        self.page = self.page + 1
        self:updateCells(true)
        self:updatePageDesc()
    end)

    self.curTab = nil
    self.curCfg = nil
    self.curTrays = {}
    self.selectCell = nil
    self.tabIndex = 0
    self.slotIndex = 1
    self.page = 1
    self.maxPage = 1
    Lib.subscribeEvent(Event.EVENT_PLAYER_ITEM_MODIFY, function()
        self:updateCells()
        if self.curCfg then
            self:updateExpandContainer(self.curCfg.showContainer)
        end
    end)

    Lib.subscribeEvent(Event.EVENT_BACKPACK_DISPLAY_RECORD, function(tid, slot)
        self.recordTid = tid
        self.recordSlot = slot
        self:updateCells()
        if self.curCfg then
            self:updateExpandContainer(self.curCfg.showContainer)
        end
    end)
end

function M:onOpen(backpackKey, titleName, regId, relativeSize)
    -- 根据backpackKey初始化本次打开对应的布局数据
    self.selectCell = nil
    self.regId = regId
    self.eventKey = backpackKey
    self.tabIndex = 0
    self.tab:invoke("CLEAN")
    local backPackCfg = Me:cfg().backpackDisplay
    self.curTab = backPackCfg and backPackCfg[backpackKey]
    self:root():SetArea({ 0, 0 }, { 0, 0 }, { relativeSize and relativeSize.w or 0.85, 0 }, { relativeSize and relativeSize.h or 0.78, 0 })
    if not self.curTab then
        self:closeSelf()
        return
    end
    if titleName then
        self.titleName:SetText(Lang:toText(titleName))
    end
    self.titleNameText = titleName
    self:initTab()
end

function M:refreshUI()
    -- 更新页面布局
    local width = self.tab_layout:GetWidth()
    local visible = self.tab_layout:IsVisible()
    local widthChange = visible and -width[1] or 0
    self.mainContent:SetWidth({ 1 + widthChange, 0 })
end

--初始页签
function M:initTab()
    if #self.curTab == 1 then
        -- 只有单个标签页不需要展示
        self.tab_layout:SetVisible(false)
        self:refreshUI()
        self:initContent(self.curTab[1] or {})
        return
    end
    self.tab_layout:SetVisible(true)
    self:refreshUI()
    for i, t in ipairs(self.curTab) do
        self.tab:invoke("ADD_BUTTON", t.tab, function(radioBtn)
            self.tabIndex = i - 1
            self.slotIndex = 1
            self.titleName:SetText(Lang:toText(t.tab))
            self:initContent(t)
            if radioBtn then
                radioBtn:GetChildByIndex(0):SetTextColor({ 1, 1, 1, 1 })
            end
        end, { 255 / 255, 233 / 255, 186 / 255 }, { 111 / 255, 55 / 255, 36 / 255 }, "HT18")
        if (i - 1) == self.tabIndex then
            self.tab:invoke("SELECTED", self.tabIndex)
        end
    end
end

--初始主要内容
function M:initContent(cfg)
	self.emptyFrame:SetVisible(true)
	self.emptyFrame:GetChildByIndex(0):SetText(Lang:toText({"empty.frame.tip",cfg.tab or self.titleNameText}))
    self.page = 1
    self.gridView:invoke("CLEAN")
    self.curCfg = cfg
    self:resetDesc()
    local capacityLimit = cfg.capacityLimit
    local trayType = cfg.trayType
    trayType = trayType or { Define.TRAY_TYPE.HAND_BAG, Define.TRAY_TYPE.BAG, Define.TRAY_TYPE.EXTRA_BAG, }
    -- 1、根据filters里的filterTray进行物品的过滤显示
    self:filterTray(trayType, cfg.filterTray or {}, cfg.filterKey, cfg.sortGist, cfg.sortVar)

    self:updateExpandContainer(cfg.showContainer)

    -- 3、最终用排序完的有序的表进行展示
    local tray = capacityLimit and Me:tray():query_trays(trayType)
    local limitCount = 0
    for _, t in pairs(tray or {}) do
        limitCount = limitCount + t.tray:capacity()
    end
    local count = capacityLimit and limitCount or #self.curTrays
    count = count == 0 and 1 or count
    self.maxPage = count // 9 + (count % 9 == 0 and 0 or 1)
    self:updatePageDesc()
    self:showContent(limitCount > 0 and limitCount or false, cfg.frameSize)
end

--背包过滤
function M:filterTray(trayType, filters, filterKey, sortGist, sortVar)
    self.curTrays = {}
    local trayArray = Me:tray():query_trays(trayType)
    for _, element in pairs(trayArray) do
        local tray = element.tray
        local items = tray and tray:query_items(function(item)
            if filterKey and item:cfg()[filterKey] then
                return true
            end
            for _, v in pairs(filters) do
                if item:tray_type()[v] then
                    return true
                end
            end
            return false
        end)
        for _, item in pairs(items) do
            table.insert(self.curTrays, item)
        end
    end
    table.sort(self.curTrays, function(item1, item2)
        local type1 = Me:tray():fetch_tray(item1:tid()):type()
        local type2 = Me:tray():fetch_tray(item2:tid()):type()
        if type1 ~= type2 then
            if Define.TRAY_TYPE_CLASS[type1] ~= Define.TRAY_TYPE_CLASS[type2] then
                return Define.TRAY_TYPE_CLASS[type1] == Define.TRAY_CLASS_EQUIP and Define.TRAY_TYPE_CLASS[type2] ~= Define.TRAY_CLASS_EQUIP
            end
        end
        if sortVar then
            local var_1, var_2 = item1:var(sortVar), item2:var(sortVar)
            if var_1 and not var_2 then
                return true
            elseif var_2 and not var_1 then
                return false
            end
        end
        if sortGist then
            local gist_1, gist_2 = item1:cfg()[sortGist], item2:cfg()[sortGist]
            if gist_1 and gist_2 then
                if gist_1 ~= gist_2 then
                    return gist_1 > gist_2
                end
            elseif gist_2 then
                return false
            end
        end
        return false
    end)
end

--主内容显示
function M:showContent(limitCount, frameSize)
    local count = #self.curTrays == 0 and 1 or #self.curTrays
    count = count // 3 + (count % 3 > 0 and 1 or 0)
    local index = 1
    for i = 1, limitCount or (count * 3) do
        -- 创建item加入gridView
        if i // 9 + (i % 9 == 0 and 0 or 1) ~= self.page then
            goto continue
        end
        local cell = getCell(index)
		cell:SetName("cell-"..index)
        cell:setData("item", self.curTrays[i])
        self:refreshItem(cell, index, frameSize)
        index = index + 1
        :: continue ::
    end
end

function M:updateCells(noSort)
    self.slotIndex = 1
    self:resetDesc()
    self.gridView:invoke("CLEAN")
    local cfg = self.curCfg
    if not cfg then
        return
    end
    local trayType = cfg.trayType
    trayType = trayType or { Define.TRAY_TYPE.HAND_BAG, Define.TRAY_TYPE.BAG, Define.TRAY_TYPE.EXTRA_BAG, }
    if not noSort then
        self:filterTray(trayType, cfg.filterTray or {}, cfg.filterKey, cfg.sortGist, cfg.sortVar)
    end
    local capacityLimit = cfg.capacityLimit
    local tray = capacityLimit and Me:tray():query_trays(trayType)
    local limitCount = 0
    for _, t in pairs(tray or {}) do
        limitCount = limitCount + t.tray:capacity()
    end
    local count = capacityLimit and limitCount or (#self.curTrays == 0 and 1 or #self.curTrays)
    count = count // 3 + (count % 3 > 0 and 1 or 0)
    local index = 1
    for i = 1, count * 3 do
        if i // 9 + (i % 9 == 0 and 0 or 1) ~= self.page then
            goto continue
        end
        local item = self.curTrays[i]
        local cell = getCell()
        cell:setData("item", item)
        self:refreshItem(cell, index, cfg.frameSize)
        if item and self.recordTid == item:tid() and self.recordSlot == item:slot() then
            self.slotIndex = index
            self:resetCell(cell)
            self:initDesc(cell)
        end
        index = index + 1
        :: continue ::
    end
    self.recordTid = nil
    self.recordSlot = nil
end

function M:updateExpandContainer(containerCfg)
    -- 更新背包展示容量 并调整布局
    local tray = containerCfg and containerCfg.tray
    self.topContainer:SetVisible(tray)
    self.contentContainer:SetHeight({ 0.77, tray and -30 or 0 })
    if not tray then
        return
    end
    local ret = Me:tray():query_trays(tray)
    local residue, total = 0, 0
    for _, element in pairs(ret) do
        local _tray = element.tray
        total = total + _tray:capacity()
        residue = residue + (_tray:capacity() - _tray:avail_capacity())
    end
    self.expandContainerShow:SetText(string.format("%d/%d", residue, total))
    self:unsubscribe(self.expandContainerBtn)
    self:subscribe(self.expandContainerBtn, UIEvent.EventButtonClick, function()
        Me:doCallBack("backpackDisplay", self.eventKey, self.regId, { tray = tray })
    end)
end

function M:resetCell(cell)
    local curCell = self.selectCell
    self.selectCell = nil
    if curCell and curCell ~= cell and curCell:receiver() then
        curCell:receiver():onClick(false)
    end
    if cell and cell:receiver() then
        cell:receiver():onClick(true)
        self.selectCell = cell
    end
end

frameDesc.PetLevel = function(item, params)
    local level = item:var(params.key) or 1
    return params.langKey and Lang:toText({ params.langKey, level } or level)
end

frameDesc.ItemLevel = function(item, params)
    local curLevel = item:getValue(params.key)
    if not curLevel or curLevel == 0 then
        return ""
    end
    return params.langKey and Lang:toText({ params.langKey, curLevel } or curLevel)
end

function M:updateRefreshItem(template)
end

--更新每个item的信息
function M:refreshItem(template, index)
    local item = template:data("item")
    local qualityCfg = World.cfg.trayQualityFrame
    template:invoke("RESET")
    if qualityCfg then
        template:invoke("SELECT_TYPE", item, qualityCfg.selectType)
        template:invoke("FRAME_IMAGE", item, qualityCfg.defaultIcon, qualityCfg.frameStretch)
        template:invoke("FRAME_SELECT_IMAGE", item, qualityCfg.selectFrameIcon, qualityCfg.selectStretch)
    end
    local pixelSize = self.contentContainer:GetPixelSize()
    template:invoke("FRAME_SIZE", item, pixelSize.x / 3 - 10, pixelSize.y / 3 - 10)
    self.gridView:invoke("ITEM", template)
    self:unsubscribe(template)
    if not item or item:null() then
        return
    end
    self:subscribe(template, UIEvent.EventWindowClick, function()
        if self.slotIndex == index then
            return
        end
        self.slotIndex = index
        self:resetCell(template)
        self:initDesc(template)
    end)
    local cfg = item:cfg()
    local quality = cfg.quality
    local qualityDiff = qualityCfg.qualityFrameDiff
    if quality and qualityDiff and qualityDiff[quality] then
        template:invoke("FRAME_IMAGE", item, qualityDiff[quality].icon, qualityDiff[quality].stretch or qualityCfg.frameStretch)
    end
    template:invoke("ITEM_SLOTER", item)
    template:invoke("SHOW_EFFECT", item)
    -- 如果item配置里有showActor的字段 就显示actor
    if cfg.showActor then
        template:invoke("ACTOR_ITEM", item, cfg.showActor)
    end
    if cfg.signIcon then
        local icon = ResLoader:loadImage(cfg, cfg.signIcon)
        template:invoke("ITEM_SIGN", item, icon)
    end
    local starLevel = cfg.starLevel
    if starLevel then
        template:invoke("SHOW_STAR_LEVEL", item, starLevel.level, ResLoader:loadImage(cfg, starLevel.icon), starLevel.width, starLevel.height)
    end
    local unlockFrame = self.curCfg.unlockFrame
    if unlockFrame and unlockFrame.var then
        local unlock = item:var(unlockFrame.var)
        template:invoke("SHOW_LOCKED", item, not unlock, unlockFrame.lockImage or "", unlockFrame.area)
    end
    if self.curCfg.hideQuantity then
        template:invoke("LD_BOTTOM", item, "")
    end
    local fd = self.curCfg.frameDesc or {}
    if next(fd) then
        local frameProc = assert(frameDesc[fd.type], fd.key)
        local text = frameProc(item, fd)
        template:invoke("LD_BOTTOM", item, text, "HT18")
    end

    if index == self.slotIndex then
        -- self:resetCell(template)
        template:receiver():onClick(true)
        self.selectCell = template
        self:initDesc(template)
    end
    self:updateRefreshItem(template)
end

function M:updatePageDesc()
    self.pageDesc:SetText(self.page .. " / " .. self.maxPage)
end

function M:resetDesc()
    local dataWnd = self.desc:data("wnd")
    if dataWnd then
        UI:closeWnd(dataWnd)
    end
    while self.desc:GetChildCount() ~= 0 do
        local wnd = self.desc:GetChildByIndex(0)
        self.desc:RemoveChildWindow1(wnd)
    end
end

--初始选择的信息展示
function M:initDesc(cell)
    self:resetDesc()
	self.emptyFrame:SetVisible(false)
    local item = cell:data("item")
    if not item or item:null() then
		if #self.curTrays==0 then
			self.emptyFrame:SetVisible(true)
		end
        return
    end
    local cfg = self.curCfg or {}
    local frameType = cfg.frameType or "item"
    local descContent = UI:openWnd(frameType .. "_frame", cell, cfg, self.eventKey, self.regId)
    self.desc:AddChildWindow(descContent:root())
    self.desc:setData("wnd", descContent)
end

function M:closeSelf()
    UI:closeWnd("backpack_display")
end

function M:onClose()
    self.slotIndex = 1
    self.recordTid = nil
    self.recordSlot = nil
    self.page = 1
    self.maxPage = 1
    self:resetDesc()
    self.gridView:invoke("CLEAN")
    self.selectCell = nil
end

return M