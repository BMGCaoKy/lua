---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by work.
--- DateTime: 2019/10/10 18:18
---
local keyBtn = { "candestroy", "tray", "openEvent" }
local keyEvent = {}
local extendType = {
    Property = {},
    Time = {}
}
local frameDesc = {}
local stopCdTimer = nil
local IS_OPEN = false
local allEvent = {}

function M:init()
    WinBase.init(self, "ItemFrame.json")

    self.qualityDesc = self:child("ItemFrame-Quality-Text")
    self.itemIcon = self:child("ItemFrame-Items-Icon")
    -- self.itemActor = self:child("ItemFrame-Items-Icon-Actor")
    self.itemName = self:child("ItemFrame-Item-Name")
    self.slider = self:child("ItemFrame-Slider")
    self.sliderText = self:child("ItemFrame-Slider-Text")

    self.extendContent = self:child("ItemFrame-Item-Extend")
    self.btnContainer = UIMgr:new_widget("grid_view")
    self.btnContainer:invoke("INIT_CONFIG", 5, 5, 1)
    self.btnContainer:invoke("ITEM_ALIGNMENT", 1)
    self.btnContainer:invoke("AUTO_COLUMN", false)
    self.btnContainer:invoke("MOVE_ABLE", false)
    self:child("ItemFrame-Btn"):AddChildWindow(self.btnContainer)

    self.cell = UIMgr:new_widget("cell")
    self.itemIcon:AddChildWindow(self.cell)
    self.shrinkHeight = 0
    Lib.subscribeEvent(Event.EVENT_PLAYER_ITEM_MODIFY, function()
        if not IS_OPEN then
            return
        end
		self:onOpen(self.curCell, self.cfg, self.eventKey, self.regId)
    end)
end

function M:onOpen(cell, cfg, key, regId)
    if not cfg then return end 
    IS_OPEN = true
    self.cfg = cfg
    self.eventKey = key
    self.regId = regId
    self:resetContent()
    self.canUnwield = cfg.canUnwield
    local item = cell and cell:data("item")
    if not item or item:null() then
        return
    end
    self.curCell = cell
    self:initMainContent(item)
end

function M:resetContent()
    self.itemName:SetText("")
    self.qualityDesc:SetText("")
    self.extendContent:CleanupChildren()
    self.btnContainer:invoke("CLEAN")
    self.cell:invoke("RESET")
    self.cell:invoke("FRAME_IMAGE", nil, "")
	if stopCdTimer then
		stopCdTimer()
	end
end

frameDesc.PetLevel = function(item, params)
    local petIndex = item:var(params.key)
    local petEntity = petIndex and Me:getPet(petIndex)
    if not petEntity then
        return ""
    end
    local level = petEntity:getValue("level")
    return params.langKey and Lang:toText({ params.langKey, level } or level)
end

frameDesc.ItemLevel = function(item, params)
    local curLevel = item:getValue(params.key)
    if not curLevel or curLevel == 0 then
        return ""
    end
    return params.langKey and Lang:toText({params.langKey, curLevel} or curLevel)
end

-- 初始主要内容
function M:initMainContent(item)
    self.cell:invoke("RESET", item)
    self:resetContent()
    local qualityCfg = World.cfg.trayQualityFrame
    if qualityCfg then
        self.cell:invoke("SELECT_TYPE", item, qualityCfg.selectType)
        self.cell:invoke("FRAME_IMAGE", item, qualityCfg.defaultIcon, qualityCfg.frameStretch)
        self.cell:invoke("FRAME_SELECT_IMAGE", item, qualityCfg.selectFrameIcon, qualityCfg.selectStretch)
    end
    self.cell:invoke("FRAME_AREA", item, { 0, 0 }, { 0, 0 }, { 1, 0 }, { 1, 0 })
    local cfg = item:cfg()
    local quality = cfg.quality
    local qualityDiff = qualityCfg.qualityFrameDiff
    if quality and qualityDiff and qualityDiff[quality] then
        self.cell:invoke("FRAME_IMAGE", item, qualityDiff[quality].icon, qualityDiff[quality].stretch or qualityCfg.frameStretch)
    end
    self.cell:invoke("ITEM_SLOTER", item)
    self.cell:invoke("SHOW_EFFECT", item)
    local fd = self.cfg.frameDesc or {}
    if next(fd) then
        local frameProc = assert(frameDesc[fd.type], fd.key)
        local text = frameProc(item, fd)
        self.cell:invoke("LD_BOTTOM", item, text, "HT20")
    end
    self:updateRefreshItem(self.cell)

    local starLevel = cfg.starLevel
    if starLevel then
        self.cell:invoke("SHOW_STAR_LEVEL", item, starLevel.level, ResLoader:loadImage(cfg, starLevel.icon), starLevel.width, starLevel.height)
    end

    local qualityDesc = cfg.qualityDesc
    if qualityDesc and type(qualityDesc) == "string" then
        self.qualityDesc:SetText(Lang:toText(qualityDesc))
    end
    local itemname = cfg.itemname
    if itemname and type(itemname) == "string" then
        self.itemName:SetText(Lang:toText(itemname))
    end
    if cfg.extendDesc then
        self:initExtendContent(cfg.extendDesc, cfg, item)
    end
    self:initBtn(item)
end

function M:updateRefreshItem(template)
end

extendType.Time = function(times, wnd, cfg, item)
	local function updata(openCD, updataWnd, wnd)
		local hour, minitue, second = Lib.timeFormatting(openCD)
		local countDown = openCD
		updataWnd:SetText(hour.." : "..minitue.." : "..second.."  "..Lang:toText("gui.text.free" or ""))
		local function tick()
			countDown = countDown - 1
			local c_h, c_m, c_s = Lib.timeFormatting(countDown)
			updataWnd:SetText(c_h.." : "..c_m.." : "..c_s.."  "..Lang:toText("gui.text.free" or ""))
			if countDown <= 0 then
				wnd:child("TimePanel"):SetVisible(false)
				return false
			end
			return true
		end
		stopCdTimer = World.Timer(20, tick)
	end
	if Me:data("treasurebox") and Me:data("treasurebox")[item:full_name()] then
		local treasureBox = Me:data("treasurebox")[item:full_name()]
		local currOpencd = treasureBox.openCD - os.time()
		if currOpencd > 0 and treasureBox.isopen then
			local timePanel = GUIWindowManager.instance:CreateGUIWindow1("Layout", "TimePanel")
			timePanel:SetArea({ 0, 0 }, { 0, 0 }, { 1, 0 }, { 3, 0 })
			timePanel:SetBackgroundColor({ 187 / 255, 146 / 255, 110 / 255, 1 })

			local timeIcon = GUIWindowManager.instance:CreateGUIWindow1("StaticImage", "TimeIcon")
			timeIcon:SetArea({ 0.365, 0 }, { 0.02, 0 }, { 0, 80 }, { 0, 80 })
			timeIcon:SetImage(ResLoader:loadImage(cfg, treasureBox.lottery.timeIcon))
			timePanel:AddChildWindow(timeIcon)

			local timeBar = GUIWindowManager.instance:CreateGUIWindow1("StaticImage", "TimeBar")
			timeBar:SetArea({ 0, 50 }, { 0, 110 }, { 0, 220 }, { 0, 30 })
			timeBar:SetImage("set:backpack_display.json image:time_bg.png")
			timeBar:SetProperty("StretchType", "NineGrid")
			timeBar:SetProperty("StretchOffset", "35 35 0 0")
			timePanel:AddChildWindow(timeBar)

			local timeText = GUIWindowManager.instance:CreateGUIWindow1("StaticText", "TimeText")
			timeText:SetArea({ 0, 50 }, { 0, 110 }, { 0, 220 }, { 0, 30 })
			timeText:SetProperty("TextBorder", "true")
			timeText:SetTextHorzAlign(1)
			timeText:SetText("23:23:59")
			timePanel:AddChildWindow(timeText)

			wnd:AddChildWindow(timePanel)
			updata(currOpencd, wnd:child("TimeText"), wnd)
		end
	end
end

extendType.Property = function(properties, wnd, cfg, item)
    -- 基本属性的扩展内容
    wnd:CleanupChildren()
    for i, proper in pairs(properties or {}) do
        if i > 3 then
            break
        end
        local property = GUIWindowManager.instance:CreateGUIWindow1("Layout", "Item-Property-" .. i)
        property:SetArea({ 0, 0 }, { (i - 1) * (1 / 3), 0 }, { 1, 0 }, { 1 / 3, 0 })
        property:SetBackgroundColor(i % 2 == 1 and { 187 / 255, 146 / 255, 110 / 255, 1 } or { 182 / 255, 129 / 255, 102 / 255, 1 })
        local proName = GUIWindowManager.instance:CreateGUIWindow1("StaticText", "Item-Property-Name-" .. i)
        proName:SetArea({ 0.05, 0 }, { 0, 0 }, { 0, 0 }, { 1, 0 })
        proName:SetTextVertAlign(1)
        proName:SetText(Lang:toText(proper.langKey))
        proName:SetProperty("Font", "HT16")
        proName:SetTextColor({ 255 / 255, 233 / 255, 186 / 255, 1 })
        proName:SetProperty("TextBorder", "true")
        proName:SetProperty("TextRenderOffset", "0 -5")
        proName:SetTextBoader({ 119 / 255, 30 / 255, 21 / 255, 1 })
        property:AddChildWindow(proName)
        local icon = GUIWindowManager.instance:CreateGUIWindow1("StaticImage", "Item-Property-Icon-" .. i)
        icon:SetArea({ 0.4, 0 }, { 0, 0 }, { 0, 30 }, { 0, 30 })
        icon:SetVerticalAlignment(1)
        icon:SetImage(ResLoader:loadImage(cfg, proper.icon))
        property:AddChildWindow(icon)
        local value = GUIWindowManager.instance:CreateGUIWindow1("StaticText", "Item-Property-Value-" .. i)
        local curLv = item:getValue("curLevel")
        local gainBuffName = item:equip_levelBuff(curLv)
        local gainBuff = gainBuffName and Entity.BuffCfg(gainBuffName) or {}
        local gain = proper.gainKey and gainBuff[proper.gainKey] or 0
        value:SetArea({ 0.7, 0 }, { 0, 0 }, { 0, 0 }, { 1, 0 })
        value:SetText(proper.value and (proper.value + gain) or "")
        value:SetTextVertAlign(1)
        value:SetProperty("Font", "HT14")
        value:SetProperty("TextBorder", "true")
        value:SetProperty("TextRenderOffset", "0 -5")
        value:SetTextBoader({ 119 / 255, 30 / 255, 21 / 255, 1 })
        property:AddChildWindow(value)
        wnd:AddChildWindow(property)
    end
end

-- 初始扩充的内容 主要是显示属性/时间/描述....
function M:initExtendContent(extendCfg, cfg, item)
    if not type(extendCfg) == "table" then
        return
    end
    local proc = extendCfg.type and extendType[extendCfg.type] or {}
    if type(proc) == "function" and extendCfg.value then
        proc(extendCfg.value, self.extendContent, cfg, item)
    end
end

local function createBtn(text, image, boaderColor)
    local btn = GUIWindowManager.instance:CreateGUIWindow1("Button", "Item-Frame-Btn-" .. text)
    btn:SetWidth({ 0, 190 })
    btn:SetHeight({ 1, -10 })
    btn:SetNormalImage(image)
    btn:SetPushedImage(image)
    btn:SetProperty("StretchType", "NineGrid")
    btn:SetProperty("StretchOffset", "70 90 0 0")
    local btnName = GUIWindowManager.instance:CreateGUIWindow1("StaticText", "Item-Frame-Name-" .. text)
    btnName:SetArea({ 0, 0 }, { 0, -5 }, { 1, 0 }, { 1, 0 })
    btnName:SetProperty("Font", "HT18")
    btnName:SetText(Lang:toText(text))
    btnName:SetTextHorzAlign(1)
    btnName:SetTextVertAlign(1)
    btnName:SetTextColor({ 217 / 255, 255 / 255, 253 / 255, 1 })
    btnName:SetProperty("TextBorder", true)
    btnName:SetTextBoader(boaderColor or { 0 / 255, 34 / 255, 96 / 255, 1 })
    btn:AddChildWindow(btnName)
    return btn
end

local function unifyProc(self, btn, proc)
    if not IS_OPEN then
        return
    end
    allEvent[#allEvent + 1] = self:subscribe(btn, UIEvent.EventButtonClick, function()
        -- self:unsubscribe(btn)
        -- World.Timer(20, function()
        --     if btn then
        --         unifyProc(self, btn, proc)
        --     end
        -- end)
        if proc then
            proc()
        end
    end)
end

local function canEquipTrayTid(item, trayType)
    local types = item:tray_type()
    local _tid, slot
    for tid, _ in pairs(types) do
        local ret = Me:tray():query_trays(tid)
        for _, element in pairs(ret) do
            local _tray = element.tray
            if Define.TRAY_TYPE_CLASS[_tray:type()] == Define.TRAY_TYPE_CLASS[trayType] then
                break
            end
            _tid = element.tid
            slot = _tray:find_free() or _tray:capacity()
            return _tid, slot
        end
    end
end

keyEvent.openEvent = function(self, params, item)
    local btn = createBtn("item.frame.open.btn", "set:new_gui_treasurebox.json image:blue_btn_bg.png")
    --todo 进行不同btn样式定义
    local func
    local fullName = item:full_name()
    if params == self.eventKey then
        func = function()
            Me:doCallBack("backpackDisplay", self.eventKey, self.regId, { fullName = fullName })
        end
    end
    unifyProc(self, btn, func)
    return btn
end

keyEvent.candestroy = function(self, _, item)
    local btn = createBtn("item.frame.destroy.btn", "set:new_gui_treasurebox.json image:red_btn_bg.png")
    --todo 进行物品销毁
    local function func()
        if item then
            Me:sendPacket({ pid = "DeleteItem", objID = Me.objID, bag = item:tid(), slot = item:slot() })
        end
    end
    unifyProc(self, btn, func)
    return btn
end

keyEvent.tray = function(self, params, item)
    --todo 进行物品的装备与卸下
    local equip = true
    local tid, slot = item:tid(), item:slot()
    local tray = Me:tray():fetch_tray(tid)
    local trayType = tray:type()
    local equipTid, equipSlot = canEquipTrayTid(item, trayType)
    if Define.TRAY_TYPE_CLASS[trayType] == Define.TRAY_CLASS_BAG then
        equip = true
    elseif Define.TRAY_TYPE_CLASS[trayType] == Define.TRAY_CLASS_EQUIP then
        equip = false
    end
    local btn = createBtn(equip and "item.frame.equip.btn" or "item.frame.unequip.btn", "set:new_gui_treasurebox.json image:blue_btn_bg.png")
    local function func()
        Me:switchItem(tid, slot, equipTid, equipSlot, function(ret)
            if ret then
                Lib.emitEvent(Event.EVENT_BACKPACK_DISPLAY_RECORD, equipTid, equipSlot)
            end
        end)
    end
    if equip or self.canUnwield then
        unifyProc(self, btn, func)
    end
    return btn
end

--todo 初始当前item可以进行的btn操作
function M:initBtn(item)
    self.btnContainer:invoke("CLEAN")
    local cfg = item:cfg()
    for _, key in ipairs(keyBtn) do
        local ret = cfg[key]
        if ret then
            local proc = keyEvent[key]
            if proc and type(proc) == "function" then
                local btn = proc(self, ret, item)
                if btn then
                    self.btnContainer:invoke("ITEM", btn)
                end
            end
            break
        end
    end
end

function M:onClose()
    IS_OPEN = false
    self:resetContent()
    for _, close in pairs(allEvent) do
        close()
    end
end

return M