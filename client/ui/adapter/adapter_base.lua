---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by 10184.
--- DateTime: 2020/5/7 17:05
---

---计算需要创建的view的数量
local function calculateCreateViewCount(adapter)
    if adapter.view:getOrientation() == 0 then
        local row = adapter.view:ROW_SIZE()
        local height = adapter.view:HEIGHT()
        local space = adapter.view:VERTICAL_SPACE()
        local size = adapter:getItemHeight()
        local itemH = height * size[1] + size[2]
        local col = math.ceil((height + space) / itemH) + 1
        return row * col
    else
        local width = adapter.view:WIDTH()
        local size = adapter:getItemWidth()
        local space = adapter.view:HORIZONTAL_SPACE()
        local itemW = width * size[1] + size[2]
        local col = math.ceil((width + space) / itemW)
        return col + 2
    end
end

---计算出第一个显示的item的位置
local function calculateFirstItemPosition(adapter)
    if adapter.view:getOrientation() == 0 then
        local row = adapter.view:ROW_SIZE()
        local height = adapter.view:HEIGHT()
        local space = adapter.view:VERTICAL_SPACE()
        local size = adapter:getItemHeight()
        local itemH = height * size[1] + size[2]
        local col = math.ceil(-adapter.offset / (itemH + space)) - 1
        local firstItemPos = math.max(row * col + 1, 1)
        local maxFirstPos = adapter:getItemCount() - calculateCreateViewCount(adapter) + row
        if firstItemPos > maxFirstPos then
            return math.min(adapter.firstItemPos, firstItemPos)
        else
            return firstItemPos
        end
    else
        local size = adapter:getItemWidth()
        local height = adapter.view:WIDTH()
        local space = adapter.view:HORIZONTAL_SPACE()
        local itemW = height * size[1] + size[2]
        local col = math.ceil(-adapter.offset / (itemW + space)) - 1
        local firstItemPos = math.max(col + 1, 1)
        if firstItemPos > adapter:getItemCount() - calculateCreateViewCount(adapter) + 1 then
            return adapter.firstItemPos
        else
            return firstItemPos
        end
    end
end

---重新设置虚拟列表的可滑动的增量值
local function resetVirtualListOffset(adapter, firstItemPos)
    if adapter.view:getOrientation() == 0 then
        local height = adapter.view:HEIGHT()
        local space = adapter.view:VERTICAL_SPACE()
        local size = adapter:getItemHeight()
        local itemH = height * size[1] + size[2]
        local offset = (firstItemPos - 1) / adapter.view:ROW_SIZE() * (itemH + space)
        adapter.view:root():SetVirtualListOffset(offset)
    else
        local size = adapter:getItemWidth()
        local height = adapter.view:WIDTH()
        local itemW = height * size[1] + size[2]
        local space = adapter.view:HORIZONTAL_SPACE()
        local offset = (firstItemPos - 1) * (itemW + space)
        adapter.view:root():SetVirtualListOffset(offset)
    end
end

---@class adapter_base
local M = {}

function M:init()
    self.view = nil
    self.data = {}
    self.offset = 0
    self.firstItemPos = 1
end

---@param view widget_adapter_view
function M:setView(view)
    self.view = view
    self.view:subscribe(self.view:root(), UIEvent.EventScrollMoveChange, function()
        local offset = self.view:root():GetScrollOffset()
        if self.offset == offset then
            return
        end
        self.offset = offset
        ---TODO 需要更新每个item view的坐标 使其坐标变大变小 让scroll能继续滑动
        self:updateUI(false)
    end)
end

function M:updateUI(force, updatePos)
    if not self.view then
        return
    end
    local oldFirstItemPos = self.firstItemPos
    if not force then
        local newFirstItemPos = calculateFirstItemPosition(self)
        if newFirstItemPos == oldFirstItemPos then
            if self.bottomCall and self:isBottom() then
                self.bottomCall()
            end
            return
        end
        self.firstItemPos = newFirstItemPos
    end
    local needCount = math.min(calculateCreateViewCount(self), #self.data) --需要显示的view数量
    if updatePos ~= nil then
        updatePos = updatePos - self.firstItemPos + 1
    else
        updatePos = 1
    end
    if updatePos > needCount then
        return
    end
    local childCount = self.view:CHILD_COUNT()
    if force or oldFirstItemPos == self.firstItemPos then
        for pos = updatePos, needCount do
            self:updateItemUI(pos + self.firstItemPos - 1)
        end
    elseif oldFirstItemPos < self.firstItemPos then
        local count = self.firstItemPos - oldFirstItemPos
        for _ = updatePos, updatePos + count - 1 do
            local window = self.view:GET_ITEM(0)
            if window then
                self.view:root():AddItem(window)
            end
        end
        for pos = needCount - count + 1, needCount do
            self:updateItemUI(pos + self.firstItemPos - 1)
        end
    else
        local count = oldFirstItemPos - self.firstItemPos
        for pos = needCount - count + 1, needCount do
            if pos <= childCount and pos > 0 then
                local window = self.view:GET_ITEM(self.view:CHILD_COUNT() - 1)
                if window then
                    self.view:root():AddItem1(window, "", 0)
                end
            end
        end
        for pos = updatePos, updatePos + count - 1 do
            self:updateItemUI(pos + self.firstItemPos - 1)
        end
    end
    for index = updatePos, childCount do
        local window = self.view:GET_ITEM(index - 1)
        if window and not self.data[index + self.firstItemPos - 1] then
            window:SetVisible(false)
        end
    end
    resetVirtualListOffset(self, self.firstItemPos)
    if self.isAutoHeight then
        self.view:root():LayoutChild()
    end
end

function M:setBottomCall(cb)
    if type(cb) == "function" then
        self.bottomCall = cb
    else
        perror("bottomCall must a function")
    end
end

function M:isBottom()
    local rowLen = self:getItemCount() / self.view:ROW_SIZE()
    local height = self.view:HEIGHT()
    local size = self:getItemHeight()
    local itemH = height * size[1] + size[2]
    -- print("itemH:",itemH)
    -- print("self.view:VERTICAL_SPACE():",self.view:VERTICAL_SPACE())
    -- print("rowLen:",rowLen)
    local bottomOffset = math.min(0, self.view:HEIGHT() - (rowLen * itemH + ((rowLen - 1) * self.view:VERTICAL_SPACE())))
    -- print("bottomOffset:",bottomOffset)
    -- print("self.view:root():GetScrollOffset()",self.view:root():GetScrollOffset())
    return self.view:root():GetScrollOffset() <= bottomOffset
end

function M:enableAutoHeight()
    if self.view:root():GetTypeStr() ~= "List" then
        Lib.logError("M:enableAutoHeight() error, can not set auto height other than List.", debug.traceback())
        return
    end
    self.isAutoHeight = true
end

function M:setScrollOffset(offset)
    self.offset = offset
    self.firstItemPos = calculateFirstItemPosition(self)
    resetVirtualListOffset(self, self.firstItemPos)
    self.view:root():SetScrollOffset(offset)
    self:updateUI(true)
end

---更新第position条数据的UI
function M:updateItemUI(position)
    local childIndex = position - self.firstItemPos
    if childIndex < 0 or childIndex >= self.view:CHILD_COUNT() then
        return
    end
    local window = self.view:GET_ITEM(position - self.firstItemPos)
    local data = self.data[position]
    if window and data then
        window:SetVisible(true)
        window:invoke("onDataChanged", data)
    end
end

---必须重写，返回子UI的json文件名
function M:getJsonName()
    return nil
end

---必须重写，返回子UI的widget名称
function M:getWidgetName()
    return "base"
end

---返回数据的数量
function M:getItemCount()
    return #self.data
end

---必须重写，返回子UI的宽度
function M:getItemWidth()
    return { 0, 0 }
end

---必须重写，返回子UI的高度
function M:getItemHeight()
    return { 0, 0 }
end

---设置整个列表的数据
function M:setData(data)
    self.data = data
    self:notifyDataChange()
end

---添加多个数据
---@param items table 数据
---@param startPos number 插入的位置
function M:addItems(items, startPos)
    startPos = startPos or #self.data + 1
    local curPos = startPos
    for _, item in pairs(items) do
        self:addItem(item, curPos)
        curPos = curPos + 1
    end
    self:notifyDataChange(startPos)
end

---添加一个数据
---@param item table 任何类型数据
---@param position number 插入的位置
function M:addItem(item, position)
    position = position or #self.data + 1
    position = math.max(math.min(position, #self.data + 1), 1)
    table.insert(self.data, position, item)
    self:notifyDataChange(position)
end

---获取某个item的位置
function M:getItemPosition(item, key)
    for pos, _item in pairs(self.data) do
        if _item[key] == item[key] then
            return pos
        end
    end
    return -1
end

---根据位置position删除item
function M:removePosition(position)
    table.remove(self.data, position)
    self:notifyDataChange(position)
end

---根据item数据删除item
function M:removeItem(item)
    for pos, child in pairs(self.data) do
        if child == item then
            self:removePosition(pos)
            return pos
        end
    end
end

---清空数据
function M:clearItems()
    self.data = {}
    self:setScrollOffset(0)
    self:notifyDataChange()
end

---刷新页面
function M:notifyDataChange(startPos)
    if not self:getJsonName() then
        return false
    end
    local needCount = math.min(calculateCreateViewCount(self), #self.data) --需要显示的view数量
    local childCount = self.view:CHILD_COUNT() --获取当前view的数量
    if childCount < needCount then
        --如果当前view的数量不够显示的数量，则需要添加
        while childCount < needCount do
            local item = UIMgr:new_widget(self:getWidgetName(), self:getJsonName())
            item:invoke("setWidth", self:getItemWidth())
            item:invoke("setHeight", self:getItemHeight())
            if self.view:ITEM(item, true) then
                childCount = childCount + 1
            end
        end
    end
    if childCount > needCount then
        --如果当前view的数量大于显示的数量，则需要删除
        while childCount > needCount do
            if self.view:REMOVE_ITEM(childCount - 1, true) then
                childCount = childCount - 1
            end
        end
    end
    self:updateUI(true, startPos)
end

---刷新单个数据的UI
function M:notifyItemDataChange(item)
    for pos, data in pairs(self.data) do
        if item == data then
            self:updateItemUI(pos)
            break
        end
    end
    if self.isAutoHeight then
        self.view:root():LayoutChild()
    end
end

return M