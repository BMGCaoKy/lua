---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by williamoj.
--- DateTime: 2020/9/27 8:11 下午
---

local cjson = require "cjson"
local Def = require "we.def"
local Signal = require "we.signal"
local Module = require "we.gamedata.module.module"

local ActorMain = nil
local M = {}

local cancel_subscribe = nil


function M:init(main)
	ActorMain = main
	self._router = {
		-- BodyPart增删
		["^body_parts$"] = function(event, index, oval)
			local actor = ActorMain:getActor()
			if event == Def.NODE_EVENT.ON_INSERT then
				local body_part = self:get_body_part(index)
				body_part.id = actor:AddBodyPart(body_part.master_name, body_part.slave_name)
				local group_id = body_part.id
				actor:SetBodyPartDefaultUse(group_id, body_part.default_use_enable)
				-- 同步部件
				local meshs = body_part["mesh"]
				if meshs then
					for i = 1, #meshs do
						local mesh = meshs[i]
						local res_file = mesh["res_file"].asset
						if res_file ~= nil and res_file ~= "" then
							local mesh_name = actor:CheckResource(res_file)
							mesh.id = actor:AddMesh(group_id, mesh_name)
							self:reset_mesh_properties(actor, group_id, mesh.id, mesh)
						end
					end
				end
				local effects = body_part["effect"]
				if effects then
					for i = 1, #effects do
						local effect = effects[i]
						local res_file = effect["res_file"].asset
						if res_file ~= nil and res_file ~= "" then
							local effect_name = actor:CheckResource(res_file)
							effect.id = actor:AddEffect(group_id, effect_name)
							self:reset_effect_properties(actor, group_id, effect.id, effect)
						end
					end
				end
				local skins = body_part["skin"]
				if skins then
					for i = 1, #skins do
						local skin = skins[i]
						local res_file = skin["res_file"].asset
						if res_file ~= nil and res_file ~= "" then
							local skin_name = actor:CheckResource(res_file)
							skin.id = actor:AddSkin(group_id, skin_name)
							self:reset_skin_properties(actor, group_id, skin.id, skin)
						end
					end
				end
			elseif event == Def.NODE_EVENT.ON_REMOVE then
				actor:RemoveBodyPart(oval.id)
			else
				assert(false)
			end
		end,

		-- BodyPart主副名
		["^body_parts/(%d+)$"] = function(event, key, ibp, oval)
			assert(event == Def.NODE_EVENT.ON_ASSIGN)
			local actor = ActorMain:getActor()
			local body_part = self:get_body_part(ibp)
			if key == "master_name" then
				actor:SetBodyPartMasterName(body_part.id, body_part.master_name)
			elseif key == "slave_name" then
				actor:SetBodyPartSlaveName(body_part.id, body_part.slave_name)
			end
		end,

		-- Mesh增删
		["^body_parts/(%d+)/mesh$"] = function(event, index, ibp, oval)
			local actor = ActorMain:getActor()
			local group_id = self:get_body_part(ibp).id
			if event == Def.NODE_EVENT.ON_INSERT then
				local mesh = self:get_mesh(ibp, index)
				local res_file = mesh["res_file"].asset
				if res_file == nil or res_file == "" then
					return
				end
				local mesh_name = actor:CheckResource(res_file)
				mesh.id = actor:AddMesh(group_id, mesh_name)
				-- 同步属性
				--self:sync_mesh_properties(actor, group_id, mesh.id, mesh)
				self:reset_mesh_properties(actor, group_id, mesh.id, mesh)
			elseif event == Def.NODE_EVENT.ON_REMOVE then
				actor:RemoveMesh(group_id, oval.id)
			end
		end,

		-- Mesh资源
		["^body_parts/(%d+)/mesh/(%d+)/res_file$"] = function(event, key, ibp, imesh, oval)
			assert(event == Def.NODE_EVENT.ON_ASSIGN)
			if key ~= "asset" then
				return
			end
			local mesh = self:get_mesh(ibp, imesh)
			local res_file = mesh["res_file"].asset
			if res_file == oval then
				return
			end
			local actor = ActorMain:getActor()
			local group_id = self:get_body_part(ibp).id
			local old_mesh_name = oval or ""
			old_mesh_name = Lib.toFileName(old_mesh_name)
			local mesh_name = res_file or ""
			if mesh_name ~= "" then
				mesh_name = actor:CheckResource(res_file)
			end
			mesh.id = actor:ChangeMesh(group_id, mesh.id, mesh_name, old_mesh_name)
			-- 同步属性
			--self:sync_mesh_properties(actor, group_id, mesh.id, mesh)
			self:reset_mesh_properties(actor, group_id, mesh.id, mesh)
		end,

		-- Mesh挂点
		["^body_parts/(%d+)/mesh/(%d+)$"] = function(event, key, ibp, imesh, oval)
			assert(event == Def.NODE_EVENT.ON_ASSIGN)
			if key == "bind_part" then
				local actor = ActorMain:getActor()
				local bind_part = self:get_mesh(ibp, imesh).bind_part
				actor:SetMeshBindPart(self:mesh_params(ibp, imesh, bind_part))
			else
			end
		end,

		-- Mesh变换
		["^body_parts/(%d+)/mesh/(%d+)/transform/?(%g*)"] = function(event, key, ibp, imesh, subpath, oval)
			if event ~= Def.NODE_EVENT.ON_ASSIGN then
				return
			end
			local actor = ActorMain:getActor()
			local transform = self:get_mesh(ibp, imesh)["transform"]
			if subpath == "pos" then
				local pos = transform["pos"]
				actor:SetMeshPosition(self:mesh_params(ibp, imesh, pos.x, pos.y, pos.z))
			elseif subpath == "rotate" then
				local rotate = transform["rotate"]
				actor:SetMeshRotation(self:mesh_params(ibp, imesh, rotate.x, rotate.y, rotate.z))
			elseif key == "scale" then
				local scale = transform.scale
				actor:SetMeshScale(self:mesh_params(ibp, imesh, scale))
			end
		end,

		-- Mesh材质
		["^body_parts/(%d+)/mesh/(%d+)/material/?(%g*)"] = function(event, key, ibp, imesh, subpath, oval)
			if event ~= Def.NODE_EVENT.ON_ASSIGN or key == "selector" then
				return
			end
			local subpaths = Lib.splitString(subpath, "/")
			local actor = ActorMain:getActor()
			local material = self:get_mesh(ibp, imesh)["material"]
			if subpath == "alpha" then
				local alpha = material["alpha"].value
				actor:SetMeshLocalAlpha(self:mesh_params(ibp, imesh, alpha))
			elseif subpath == "discard_alpha" then
				local discard_alpha = material["discard_alpha"].value
				actor:SetMeshDiscardAlpha(self:mesh_params(ibp, imesh, discard_alpha))
			elseif subpath == "brightness" then
				local brightness = material["brightness"].value
				actor:SetMeshLocalBrightnessScale(self:mesh_params(ibp, imesh, brightness))
			elseif subpath == "overlayColor" then
				local color = Lib.toPercentageColor(material["overlayColor"])
				actor:SetMeshOverlayColor(self:mesh_params(ibp, imesh, color.r, color.g, color.b))
			elseif subpaths[1] == "hight_light" then
				if subpaths[2] == "light_color" then
					local color = Lib.toPercentageColor(material["hight_light"]["light_color"])
					actor:SetMeshSpecularColor(self:mesh_params(ibp, imesh, color.r, color.g, color.b))
				elseif subpaths[2] == "light_ratio" then
					local coef = material["hight_light"]["light_ratio"].value
					actor:SetMeshSpecularCoef(self:mesh_params(ibp, imesh, coef))
				elseif subpaths[2] == "brightness" then
					local strength = material["hight_light"]["brightness"].value
					actor:SetMeshSpecularStrength(self:mesh_params(ibp, imesh, strength))
				end
			elseif subpaths[1] == "reflex_light" then
				if subpaths[2] == "reflect_scale" then
					local scale = material["reflex_light"]["reflect_scale"].value
					actor:SetMeshReflectScale(self:mesh_params(ibp, imesh, scale))
				elseif subpaths[2] == "reflect_texture" then
					local res_file = material["reflex_light"]["reflect_texture"].asset
					if res_file == oval then
						return
					end
					local file_name = res_file or ""
					if file_name ~= "" then
						file_name = actor:CheckResource(res_file)
					end
					actor:SetMeshReflectTexture(self:mesh_params(ibp, imesh, file_name))
				elseif subpaths[2] == "reflect_mask_texture" then
					local res_file = material["reflex_light"]["reflect_mask_texture"].asset
					if res_file == oval then
						return
					end
					local file_name = res_file or ""
					if file_name ~= "" then
						file_name = actor:CheckResource(res_file)
					end
					actor:SetMeshReflectMaskTexture(self:mesh_params(ibp, imesh, file_name))
				elseif key == "enable" then
					local enabled = material["reflex_light"].enable
					actor:SetMeshUseReflect(self:mesh_params(ibp, imesh, enabled))
				end
			elseif subpaths[1] == "edge_light" then
				if subpaths[2] == "light_color" then
					local color = Lib.toPercentageColor(material["edge_light"]["light_color"])
					actor:SetMeshEdgeColor(self:mesh_params(ibp, imesh, color.r, color.g, color.b))
				elseif key == "enable" then
					local enabled = material["edge_light"].enable
					actor:SetMeshUseEdge(self:mesh_params(ibp, imesh, enabled))
				end
			elseif key == "glow_enable" then
				local enabled = material.glow_enable
				actor:SetMeshUseBloom(self:mesh_params(ibp, imesh, enabled))
			elseif key == "linght_enable" then
				local enabled = material.linght_enable
				actor:SetMeshUseOriginalColor(self:mesh_params(ibp, imesh, enabled))
			elseif key == "overlayMode" then
				local mode = material.overlayMode
				local color = Lib.toPercentageColor(material["overlayColor"])
				if mode == "no" then
					actor:SetMeshUseOverlayColorReplaceMode(self:mesh_params(ibp, imesh, false))
					actor:SetMeshOverlayColor(self:mesh_params(ibp, imesh, 1, 1, 1))
				elseif mode == "overlay" then
					actor:SetMeshUseOverlayColorReplaceMode(self:mesh_params(ibp, imesh, false))
					actor:SetMeshOverlayColor(self:mesh_params(ibp, imesh, color.r, color.g, color.b))
				elseif mode == "replace" then
					actor:SetMeshUseOverlayColorReplaceMode(self:mesh_params(ibp, imesh, true))
					actor:SetMeshOverlayColor(self:mesh_params(ibp, imesh, color.r, color.g, color.b))
				end
			else
				print("##### Not Implemented material:", subpath, key)
			end
		end,

		-- Effect增删
		["^body_parts/(%d+)/effect$"] = function(event, index, ibp, oval)
			local actor = ActorMain:getActor()
			local group_id = self:get_body_part(ibp).id
			if event == Def.NODE_EVENT.ON_INSERT then
				local effect = self:get_effect(ibp, index)
				local res_file = effect["res_file"].asset
				if res_file == nil or res_file == "" then
					return
				end
				local effect_name = actor:CheckResource(res_file)
				effect.id = actor:AddEffect(group_id, effect_name)
				-- 同步属性
				--self:sync_effect_properties(actor, group_id, effect.id, effect)
				self:reset_effect_properties(actor, group_id, effect.id, effect)
			elseif event == Def.NODE_EVENT.ON_REMOVE then
				actor:RemoveEffect(group_id, oval.id)
			end
		end,

		-- Effect资源
		["^body_parts/(%d+)/effect/(%d+)/res_file$"] = function(event, key, ibp, ieffect, oval)
			assert(event == Def.NODE_EVENT.ON_ASSIGN)
			if key ~= "asset" then
				return
			end
			local effect = self:get_effect(ibp, ieffect)
			local res_file = effect["res_file"].asset
			if res_file == oval then
				return
			end
			local actor = ActorMain:getActor()
			local group_id = self:get_body_part(ibp).id
			local old_effect_name = oval or ""
			old_effect_name = Lib.toFileName(old_effect_name)
			local effect_name = res_file or ""
			if effect_name ~= "" then
				effect_name = actor:CheckResource(res_file)
			end
			effect.id = actor:ChangeEffect(group_id, effect.id, effect_name, old_effect_name)
			-- 同步属性
			--self:sync_effect_properties(actor, group_id, effect.id, effect)
			self:reset_effect_properties(actor, group_id, effect.id, effect)
		end,

		-- Effect挂点&播放速度
		["^body_parts/(%d+)/effect/(%d+)$"] = function(event, key, ibp, ieffect, oval)
			assert(event == Def.NODE_EVENT.ON_ASSIGN)
			local actor = ActorMain:getActor()
			if key == "bind_part" then
				local bind_part = self:get_effect(ibp, ieffect).bind_part
				actor:SetEffectBindPart(self:effect_params(ibp, ieffect, bind_part))
			elseif key == "play_speed" then
				local speed = self:get_effect(ibp, ieffect).play_speed
				actor:SetEffectTimeScale(self:effect_params(ibp, ieffect, speed))
			else
			end
		end,

		-- Effect变换
		["^body_parts/(%d+)/effect/(%d+)/transform/?(%g*)"] = function(event, key, ibp, ieffect, subpath, oval)
			if event ~= Def.NODE_EVENT.ON_ASSIGN then
				return
			end
			local actor = ActorMain:getActor()
			local transform = self:get_effect(ibp, ieffect)["transform"]
			if subpath == "pos" then
				local pos = transform["pos"]
				actor:SetEffectPosition(self:effect_params(ibp, ieffect, pos.x, pos.y, pos.z))
			elseif subpath == "rotate" then
				local rotate = transform["rotate"]
				actor:SetEffectRotation(self:effect_params(ibp, ieffect, rotate.x, rotate.y, rotate.z))
			elseif key == "scale" then
				local scale = transform.scale
				actor:SetEffectScale(self:effect_params(ibp, ieffect, scale))
			end
		end,

		-- Effect材质
		["^body_parts/(%d+)/effect/(%d+)/alpha$"] = function(event, key, ibp, ieffect, subpath, oval)
			if event ~= Def.NODE_EVENT.ON_ASSIGN then
				return
			end
			local actor = ActorMain:getActor()
			local alpha = self:get_effect(ibp, ieffect)["alpha"].value
			actor:SetEffectAlpha(self:effect_params(ibp, ieffect, alpha))
		end,

		-- Skin增删
		["^body_parts/(%d+)/skin$"] = function(event, index, ibp, oval)
			local actor = ActorMain:getActor()
			local group_id = self:get_body_part(ibp).id
			if event == Def.NODE_EVENT.ON_INSERT then
				local skin = self:get_skin(ibp, index)
				local res_file = skin["res_file"].asset
				if res_file == nil or res_file == "" then
					return
				end
				local skin_name = actor:CheckResource(res_file)
				skin.id = actor:AddSkin(group_id, skin_name)
				-- 同步属性
				--self:sync_skin_properties(actor, group_id, skin.id, skin)
				self:reset_skin_properties(actor, group_id, skin.id, skin)
			elseif event == Def.NODE_EVENT.ON_REMOVE then
				actor:RemoveSkin(group_id, oval.id)
			end
		end,

		-- Skin资源
		["^body_parts/(%d+)/skin/(%d+)/res_file$"] = function(event, key, ibp, iskin, oval)
			assert(event == Def.NODE_EVENT.ON_ASSIGN)
			if key ~= "asset" then
				return
			end
			local skin = self:get_skin(ibp, iskin)
			local res_file = skin["res_file"].asset
			if res_file == oval then
				return
			end
			local actor = ActorMain:getActor()
			local group_id = self:get_body_part(ibp).id
			local old_skin_name = oval or ""
			old_skin_name = Lib.toFileName(old_skin_name)
			local skin_name = res_file or ""
			if skin_name ~= "" then
				skin_name = actor:CheckResource(res_file)
			end
			skin.id = actor:ChangeSkin(group_id, skin.id, skin_name, old_skin_name)
			-- 同步属性
			--self:sync_skin_properties(actor, group_id, skin.id, skin)
			self:reset_skin_properties(actor, group_id, skin.id, skin)
		end,

		-- Skin材质
		["^body_parts/(%d+)/skin/(%d+)/material/?(%g*)"] = function(event, key, ibp, iskin, subpath, oval)
			if event ~= Def.NODE_EVENT.ON_ASSIGN or key == "selector" then
				return
			end
			local subpaths = Lib.splitString(subpath, "/")
			local actor = ActorMain:getActor()
			local material = self:get_skin(ibp, iskin)["material"]
			if subpath == "alpha" then
				local alpha = material["alpha"].value
				actor:SetSkinLocalAlpha(self:skin_params(ibp, iskin, alpha))
			elseif subpath == "discard_alpha" then
				local discard_alpha = material["discard_alpha"].value
				actor:SetSkinDiscardAlpha(self:skin_params(ibp, iskin, discard_alpha))
			elseif subpath == "brightness" then
				local brightness = material["brightness"].value
				actor:SetSkinLocalBrightnessScale(self:skin_params(ibp, iskin, brightness))
			elseif subpath == "overlayColor" then
				local color = Lib.toPercentageColor(material["overlayColor"])
				actor:SetSkinOverlayColor(self:skin_params(ibp, iskin, color.r, color.g, color.b))
			elseif subpaths[1] == "hight_light" then
				if subpaths[2] == "light_color" then
					local color = Lib.toPercentageColor(material["hight_light"]["light_color"])
					actor:SetSkinSpecularColor(self:skin_params(ibp, iskin, color.r, color.g, color.b))
				elseif subpaths[2] == "light_ratio" then
					local coef = material["hight_light"]["light_ratio"].value
					actor:SetSkinSpecularCoef(self:skin_params(ibp, iskin, coef))
				elseif subpaths[2] == "brightness" then
					local strength = material["hight_light"]["brightness"].value
					actor:SetSkinSpecularStrength(self:skin_params(ibp, iskin, strength))
				end
			elseif subpaths[1] == "reflex_light" then
				if subpaths[2] == "reflect_scale" then
					local scale = material["reflex_light"]["reflect_scale"].value
					actor:SetSkinReflectScale(self:skin_params(ibp, iskin, scale))
				elseif subpaths[2] == "reflect_texture" then
					local res_file = material["reflex_light"]["reflect_texture"].asset
					if res_file == oval then
						return
					end
					local file_name = res_file or ""
					if file_name ~= "" then
						file_name = actor:CheckResource(res_file)
					end
					actor:SetSkinReflectTexture(self:skin_params(ibp, iskin, file_name))
				elseif subpaths[2] == "reflect_mask_texture" then
					local res_file = material["reflex_light"]["reflect_mask_texture"].asset
					if res_file == oval then
						return
					end
					local file_name = res_file or ""
					if file_name ~= "" then
						file_name = actor:CheckResource(res_file)
					end
					actor:SetSkinReflectMaskTexture(self:skin_params(ibp, iskin, file_name))
				elseif key == "enable" then
					local enabled = material["reflex_light"].enable
					actor:SetSkinUseReflect(self:skin_params(ibp, iskin, enabled))
				end
			elseif subpaths[1] == "edge_light" then
				if subpaths[2] == "light_color" then
					local color = Lib.toPercentageColor(material["edge_light"]["light_color"])
					actor:SetSkinEdgeColor(self:skin_params(ibp, iskin, color.r, color.g, color.b))
				elseif key == "enable" then
					local enabled = material["edge_light"].enable
					actor:SetSkinUseEdge(self:skin_params(ibp, iskin, enabled))
				end
			elseif key == "glow_enable" then
				local enabled = material.glow_enable
				actor:SetSkinUseBloom(self:skin_params(ibp, iskin, enabled))
			elseif key == "linght_enable" then
				local enabled = material.linght_enable
				actor:SetSkinUseOriginalColor(self:skin_params(ibp, iskin, enabled))
			elseif key == "overlayMode" then
				local mode = material.overlayMode
				local color = Lib.toPercentageColor(material["overlayColor"])
				if mode == "no" then
					actor:SetSkinUseOverlayColorReplaceMode(self:skin_params(ibp, iskin, false))
					actor:SetSkinOverlayColor(self:skin_params(ibp, iskin, 1, 1, 1))
				elseif mode == "overlay" then
					actor:SetSkinUseOverlayColorReplaceMode(self:skin_params(ibp, iskin, false))
					actor:SetSkinOverlayColor(self:skin_params(ibp, iskin, color.r, color.g, color.b))
				elseif mode == "replace" then
					actor:SetSkinUseOverlayColorReplaceMode(self:skin_params(ibp, iskin, true))
					actor:SetSkinOverlayColor(self:skin_params(ibp, iskin, color.r, color.g, color.b))
				end
			else
				print("##### Not Implemented material:", subpath, key)
			end
		end,
	}
end


function M:get_body_part(ibp)
	return self._root["body_parts"][ibp]
end


function M:get_mesh(ibp, imesh)
	return self._root["body_parts"][ibp]["mesh"][imesh]
end


function M:get_effect(ibp, ieffect)
	return self._root["body_parts"][ibp]["effect"][ieffect]
end


function M:get_skin(ibp, iskin)
	return self._root["body_parts"][ibp]["skin"][iskin]
end


function M:mesh_params(ibp, imesh, ...)
	local body_part = self._root["body_parts"][ibp]
	local mesh = body_part["mesh"][imesh]
	return body_part.id, mesh.id, ...
end


function M:effect_params(ibp, ieffect, ...)
	local body_part = self._root["body_parts"][ibp]
	local effect = body_part["effect"][ieffect]
	return body_part.id, effect.id, ...
end


function M:skin_params(ibp, iskin, ...)
	local body_part = self._root["body_parts"][ibp]
	local skin = body_part["skin"][iskin]
	return body_part.id, skin.id, ...
end


function M:sync_mesh(mesh, properties)
	mesh.bind_part = properties.bind_part
	local transform = mesh["transform"]
	local pos = transform["pos"]
	local _position = properties["position"]
	pos.x = _position[1]
	pos.y = _position[2]
	pos.z = _position[3]
	local rotate = transform["rotate"]
	local _rotation = properties["rotation"]
	rotate.x = _rotation[1]
	rotate.y = _rotation[2]
	rotate.z = _rotation[3]
	transform.scale = properties.scale
end


function M:sync_effect(effect, properties)
	effect.bind_part = properties.bind_part
	local transform = effect["transform"]
	local pos = transform["pos"]
	local _position = properties["position"]
	pos.x = _position[1]
	pos.y = _position[2]
	pos.z = _position[3]
	local rotate = transform["rotate"]
	local _rotation = properties["rotation"]
	rotate.x = _rotation[1]
	rotate.y = _rotation[2]
	rotate.z = _rotation[3]
	transform.scale = properties.scale
	effect["alpha"].value = properties.alpha
	effect.play_speed = properties.time_scale
end


function M:sync_material(material, properties)
	material["alpha"].value = properties.alpha
	material["discard_alpha"].value = properties.discard_alpha
	material.glow_enable = properties.bloom
	material["brightness"].value = properties.brightness_scale
	local overlay_color = material["overlayColor"]
	local _overlay_color = properties["overlay_color"]
	overlay_color.r = _overlay_color[1] * 255
	overlay_color.g = _overlay_color[2] * 255
	overlay_color.b = _overlay_color[3] * 255
	overlay_color.a = _overlay_color[4] * 255
	local replace_mode = properties.overlay_color_replace_mode
	if overlay_color.r > 254 and overlay_color.g > 254 and overlay_color.b > 254
			and replace_mode == false then
		material.overlayMode = "no"
	elseif replace_mode == false then
		material.overlayMode = "overlay"
	elseif replace_mode == true then
		material.overlayMode = "replace"
	end
	local specular_color = material["hight_light"]["light_color"]
	local _specular_color = properties["specular_color"]
	specular_color.r = _specular_color[1] * 255
	specular_color.g = _specular_color[2] * 255
	specular_color.b = _specular_color[3] * 255
	specular_color.a = _specular_color[4] * 255
	material["hight_light"]["light_ratio"].value = properties.specular_coef
	material["edge_light"].enable = properties.edge
	local edge_color = material["edge_light"]["light_color"]
	local _edge_color = properties["edge_color"]
	edge_color.r = _edge_color[1] * 255
	edge_color.g = _edge_color[2] * 255
	edge_color.b = _edge_color[3] * 255
	edge_color.a = _edge_color[4] * 255
	material.linght_enable = properties.original_color
end


function M:sync_mesh_properties(actor, group_id, mesh_id, mesh)
	local _properties = actor:GetMeshProperties(group_id, mesh_id)
	if _properties ~= "{}" then
		local properties = cjson.decode(_properties)
		print("### properties:", _properties)
		self:sync_mesh(mesh, properties)
		local material = mesh["material"]
		self:sync_material(material, properties)
	end
end


function M:sync_effect_properties(actor, group_id, effect_id, effect)
	local _properties = actor:GetEffectProperties(group_id, effect_id)
	if _properties ~= "{}" then
		local properties = cjson.decode(_properties)
		print("### properties:", _properties)
		self:sync_effect(effect, properties)
	end
end


function M:sync_skin_properties(actor, group_id, skin_id, skin)
	local _properties = actor:GetSkinProperties(group_id, skin_id)
	if _properties ~= "{}" then
		local properties = cjson.decode(_properties)
		print("### properties:", _properties)
		local material = skin["material"]
		self:sync_material(material, properties)
	end
end


function M:reset_mesh_properties(actor, group_id, mesh_id, mesh)
	actor:SetMeshBindPart(group_id, mesh_id, mesh.bind_part)
	local transform = mesh["transform"]
	if transform then
		actor:SetMeshScale(group_id, mesh_id, transform.scale)
		local pos = transform["pos"]
		if pos then
			actor:SetMeshPosition(group_id, mesh_id, pos.x, pos.y, pos.z)
		end
		local rotate = transform["rotate"]
		if rotate then
			actor:SetMeshRotation(group_id, mesh_id, rotate.x, rotate.y, rotate.z)
		end
	end
	local material = mesh["material"]
	if material then
		actor:SetMeshUseBloom(group_id, mesh_id, material.glow_enable)
		actor:SetMeshUseOriginalColor(group_id, mesh_id, material.linght_enable)
		local alpha = material["alpha"]
		if alpha then
			actor:SetMeshLocalAlpha(group_id, mesh_id, alpha.value)
		end
		local discard_alpha = material["discard_alpha"]
		if discard_alpha then
			actor:SetMeshDiscardAlpha(group_id, mesh_id, discard_alpha.value)
		end
		local brightness = material["brightness"]
		if brightness then
			actor:SetMeshLocalBrightnessScale(group_id, mesh_id, material["brightness"].value)
		end
		local specular = material["hight_light"]
		if specular then
			local specular_color = Lib.toPercentageColor(specular["light_color"])
			if specular_color then
				actor:SetMeshSpecularColor(group_id, mesh_id, specular_color.r, specular_color.g, specular_color.b)
			end
			local specular_coef = specular["light_ratio"].value
			if specular_coef then
				actor:SetMeshSpecularCoef(group_id, mesh_id, specular_coef)
			end
			local specular_brightness = specular["brightness"].value
			if specular_brightness then
				--
			end
		end
		local reflect = material["reflex_light"]
		if reflect then
			actor:SetMeshUseReflect(group_id, mesh_id, reflect.enable)
			local reflect_scale = reflect["reflect_scale"].value
			if reflect_scale then
				actor:SetMeshReflectScale(group_id, mesh_id, reflect_scale)
			end
			local reflect_texture = reflect["reflect_texture"].asset
			if reflect_texture then
				local file_name = reflect_texture or ""
				if file_name ~= "" then
					file_name = actor:CheckResource(reflect_texture)
				end
				actor:SetMeshReflectTexture(group_id, mesh_id, file_name)
			end
			local reflect_mask_texture = reflect["reflect_mask_texture"].asset
			if reflect_mask_texture then
				local file_name = reflect_mask_texture or ""
				if file_name ~= "" then
					file_name = actor:CheckResource(reflect_mask_texture)
				end
				actor:SetMeshReflectMaskTexture(group_id, mesh_id, file_name)
			end
		end
		local edge = material["edge_light"]
		if edge then
			actor:SetMeshUseEdge(group_id, mesh_id, edge.enable)
			local edge_color = Lib.toPercentageColor(edge["light_color"])
			if edge_color then
				actor:SetMeshEdgeColor(group_id, mesh_id, edge_color.r, edge_color.g, edge_color.b)
			end
		end
		local overlay_mode = material.overlayMode
		if overlay_mode == "no" then
			actor:SetMeshUseOverlayColorReplaceMode(group_id, mesh_id, false)
			actor:SetMeshOverlayColor(group_id, mesh_id, 1, 1, 1)
		end
		local overlay_color = Lib.toPercentageColor(material["overlayColor"])
		if overlay_color then
			if overlay_mode == "overlay" then
				actor:SetMeshUseOverlayColorReplaceMode(group_id, mesh_id, false)
				actor:SetMeshOverlayColor(group_id, mesh_id, overlay_color.r, overlay_color.g, overlay_color.b)
			elseif overlay_mode == "replace" then
				actor:SetMeshUseOverlayColorReplaceMode(group_id, mesh_id, true)
				actor:SetMeshOverlayColor(group_id, mesh_id, overlay_color.r, overlay_color.g, overlay_color.b)
			end
		end
	end
end


function M:reset_effect_properties(actor, group_id, effect_id, effect)
	actor:SetEffectBindPart(group_id, effect_id, effect.bind_part)
	actor:SetEffectTimeScale(group_id, effect_id, effect.play_speed)
	local transform = effect["transform"]
	if transform then
		actor:SetEffectScale(group_id, effect_id, transform.scale)
		local pos = transform["pos"]
		if pos then
			actor:SetEffectPosition(group_id, effect_id, pos.x, pos.y, pos.z)
		end
		local rotate = transform["rotate"]
		if rotate then
			actor:SetEffectRotation(group_id, effect_id, rotate.x, rotate.y, rotate.z)
		end
	end
	local alpha = effect["alpha"]
	if alpha then
		actor:SetEffectAlpha(group_id, effect_id, alpha.value)
	end
end


function M:reset_skin_properties(actor, group_id, skin_id, skin)
	local material = skin["material"]
	if material then
		actor:SetSkinUseBloom(group_id, skin_id, material.glow_enable)
		actor:SetSkinUseOriginalColor(group_id, skin_id, material.linght_enable)
		local alpha = material["alpha"]
		if alpha then
			actor:SetSkinLocalAlpha(group_id, skin_id, alpha.value)
		end
		local discard_alpha = material["discard_alpha"]
		if discard_alpha then
			actor:SetSkinDiscardAlpha(group_id, skin_id, discard_alpha.value)
		end
		local brightness = material["brightness"]
		if brightness then
			actor:SetSkinLocalBrightnessScale(group_id, skin_id, material["brightness"].value)
		end
		local specular = material["hight_light"]
		if specular then
			local specular_color = Lib.toPercentageColor(specular["light_color"])
			if specular_color then
				actor:SetSkinSpecularColor(group_id, skin_id, specular_color.r, specular_color.g, specular_color.b)
			end
			local specular_coef = specular["light_ratio"].value
			if specular_coef then
				actor:SetSkinSpecularCoef(group_id, skin_id, specular_coef)
			end
			local specular_brightness = specular["brightness"].value
			if specular_brightness then
				--
			end
		end
		local reflect = material["reflex_light"]
		if reflect then
			actor:SetSkinUseReflect(group_id, skin_id, reflect.enable)
			local reflect_scale = reflect["reflect_scale"].value
			if reflect_scale then
				actor:SetSkinReflectScale(group_id, skin_id, reflect_scale)
			end
			local reflect_texture = reflect["reflect_texture"].asset
			if reflect_texture then
				local file_name = reflect_texture or ""
				if file_name ~= "" then
					file_name = actor:CheckResource(reflect_texture)
				end
				actor:SetSkinReflectTexture(group_id, skin_id, file_name)
			end
			local reflect_mask_texture = reflect["reflect_mask_texture"].asset
			if reflect_mask_texture then
				local file_name = reflect_mask_texture or ""
				if file_name ~= "" then
					file_name = actor:CheckResource(reflect_mask_texture)
				end
				actor:SetSkinReflectMaskTexture(group_id, skin_id, file_name)
			end
		end
		local edge = material["edge_light"]
		if edge then
			actor:SetSkinUseEdge(group_id, skin_id, edge.enable)
			local edge_color = Lib.toPercentageColor(edge["light_color"])
			if edge_color then
				actor:SetSkinEdgeColor(group_id, skin_id, edge_color.r, edge_color.g, edge_color.b)
			end
		end
		local overlay_mode = material.overlayMode
		if overlay_mode == "no" then
			actor:SetSkinUseOverlayColorReplaceMode(group_id, skin_id, false)
			actor:SetSkinOverlayColor(group_id, skin_id, 1, 1, 1)
		end
		local overlay_color = Lib.toPercentageColor(material["overlayColor"])
		if overlay_color then
			if overlay_mode == "overlay" then
				actor:SetSkinUseOverlayColorReplaceMode(group_id, skin_id, false)
				actor:SetSkinOverlayColor(group_id, skin_id, overlay_color.r, overlay_color.g, overlay_color.b)
			elseif overlay_mode == "replace" then
				actor:SetSkinUseOverlayColorReplaceMode(group_id, skin_id, true)
				actor:SetSkinOverlayColor(group_id, skin_id, overlay_color.r, overlay_color.g, overlay_color.b)
			end
		end
	end
end


function M:sync_actor_ids()
	local actor = ActorMain:getActor()
	local _ids = actor:GetIDs()
	if _ids ~= "{}" then
		local ids = cjson.decode(_ids)
		local id_map = ids["body_part"]
		--print("### ids:", _ids)
		if not self._root or not self._root["body_parts"] or not id_map then
			return
		end
		-- 修改ID
		for _, body_part in pairs(self._root["body_parts"]) do
			local name = body_part["master_name"] .. "." .. body_part["slave_name"] .. ".0"
			local map_bp = id_map[name]
			--print("### body_part", name, map_bp)
			if map_bp then
				body_part["id"] = map_bp["id"] or 0
				--print("### body_part['id']", body_part["id"])
				local map_mesh = map_bp["mesh"]
				--print("### mesh", map_mesh)
				if map_mesh then
					local id_mesh = map_mesh["id"]
					--print("### mesh.id", id_mesh)
					if id_mesh then
						local mesh = body_part["mesh"]
						for n, id in ipairs(id_mesh) do
							mesh[n]["id"] = id
							--print("### mesh[" .. n .. "]['id']", id)
						end
					end
				end
				local map_effect = map_bp["effect"]
				--print("### effect", map_effect)
				if map_effect then
					local id_effect = map_effect["id"]
					--print("### effect.id", id_effect)
					if id_effect then
						local effect = body_part["effect"]
						for n, id in ipairs(id_effect) do
							effect[n]["id"] = id
							--print("### effect[" .. n .. "]['id']", id)
						end
					end
				end
				local map_skin = map_bp["skin"]
				--print("### skin", map_skin)
				if map_skin then
					local id_skin = map_skin["id"]
					--print("### skin.id", id_skin)
					if id_skin then
						local skin = body_part["skin"]
						for n, id in ipairs(id_skin) do
							skin[n]["id"] = id
							--print("### skin[" .. n .. "]['id']", id)
						end
					end
				end
			end
		end
	end
end


function M:set_actor(item_id)
	local root = Module:module("actor_editor"):item(item_id):obj()
	assert(root, item_id)
	self._root = root["actor_face"]

	if cancel_subscribe then
		cancel_subscribe()
	end

	cancel_subscribe = Signal:subscribe(self._root, Def.NODE_EVENT.ON_MODIFY, function(path, event, index, ...)
		-- 忽略'id'
		if index == "id" then
			return
		end
		path = table.concat(path, "/")
		local captures = nil
		for pattern, processor in pairs(self._router) do
			captures = table.pack(string.find(path, pattern))
			if #captures > 0 then
				local args = {}
				for i = 3, #captures do
					table.insert(args, math.tointeger(captures[i]) or captures[i])
				end
				for _, arg in ipairs({...}) do
					table.insert(args, arg)
				end
				print("Process:", path, event, index, table.unpack(args))
				processor(event, index, table.unpack(args))
				break
			end
		end
		if #captures <= 0 then
			print("No router for:", path, index)
		end
	end)
end


return M