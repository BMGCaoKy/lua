---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by work.
--- DateTime: 2019/4/24 18:01
---
local setting = require "common.setting"

local function init()
    Composition.Recipes = setting:mod("composition"):loadAll()
    Composition.RecipeMap = {}
    Composition.RecipeClassMap = {}
    Composition.ShowGroup = {}
    for class, cfg in pairs(Composition.Recipes) do
        local group = { { name = "All", langName = class .. ".group.All" } }
        for _, composite in pairs(cfg.composites) do
            composite.group = composite.group or "All"
            local add = true
            for _, g in ipairs(group) do
                if g.name == composite.group then
                    add = false
                    break
                end
            end
            if add then
                group[#group + 1] = { name = composite.group, langName = composite.groupName or class .. ".group." .. composite.group }
            end
        end
        Composition.RecipeClassMap[class] = cfg
        Composition.ShowGroup[class] = group
    end
    for class, cfg in pairs(Composition.RecipeClassMap) do
        cfg.composites = cfg.composites or {}
        for _, composite in ipairs(cfg.composites) do
            for _, recipe in ipairs(composite.recipes) do
                recipe.class = class
                recipe.group = composite.group or "All"
                recipe.access = recipe.access or "Innate"
                if recipe.unlockLevel or recipe.needLevel then
                    recipe.access = "Study"
                end
                recipe.cfg = cfg
                recipe.fullName = class .. "/" .. recipe.name
                Composition.RecipeMap[recipe.fullName] = recipe
            end
        end
    end
end

function Composition.Reload()
    init()
end

--class + name (类+配方名) 根据名字拿到配方内容
function Composition:getRecipe(name)
    return assert(Composition.RecipeMap[name], name)
end

function Composition:getInnateRecipes(class, group, name)
    local list = {}
    local ret = assert(Composition.RecipeClassMap[class], class)
    for _, composite in ipairs(ret.composites) do
        for _, recipe in ipairs(composite.recipes) do
            if  not group and recipe.access == "Innate" then
                list[#list + 1] = recipe.fullName
            elseif group and group == composite.group and recipe.access == "Innate" then
                list[#list + 1] = recipe.fullName
            elseif recipe.access == "Innate" and not class then
                list[#list + 1] = recipe.fullName
            end
        end
    end
    if not name then
        return list
    end
    for _, n in pairs(list) do
        if n == name then
            return false
        end
    end
    return list
end

--根据类名拿到属于这个类下的分组
function Composition:getGroupByClass(class)
    return assert(Composition.ShowGroup[class], class)
end

init()