---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Jimmy.
--- DateTime: 2019/2/15 0015 11:47
---
local TaskType = {
    Undefine = 0,
    Delay = 1,
    Period = 2,
    DelayAndPeriod = 3,
    PeriodTimer = 4,
    PeriodTicker = 5,
}

local CurTaskKey = 0

---@type LuaTimerTask[]
local TaskList = {}
---@type LuaTimerTask[]
local AddList = {}
---@type LuaTimerTask[]
local CancelList = {}

---@class LuaTimerTask
---@field action function
---@field endAction function
---@field type number
---@field times number
---@field delay number
---@field period number
---@field params any
---@field tick number
---@field time number

---@class LuaTimer
local LuaTimer = T(Lib, "LuaTimer")

local function addTask()
    for key, task in pairs(AddList) do
        TaskList[key] = task
    end
    AddList = {}
end

local function removesTask()
    for _, key in pairs(CancelList) do
        TaskList[key] = nil
    end
    CancelList = {}
end

local function actionTask(task)
    Profiler:begin("CallLuaTimer_" .. task.func_name)
    local success, error = xpcall(task.action, debug.traceback, table.unpack(task.params, 1))
    Profiler:finish("CallLuaTimer_" .. task.func_name)
    if not success then
        Lib.logError("[LuaTimer]" .. error, 2)
    end
end

function LuaTimer:printState()
    Lib.logInfo("LuaTimerState TaskList size", Lib.getTableSize(TaskList))
    Lib.logInfo("LuaTimerState AddList size", Lib.getTableSize(AddList))
    Lib.logInfo("LuaTimerState CancelList size", Lib.getTableSize(CancelList))
end

function LuaTimer:onTick(frameTime)
    if frameTime < 0 or frameTime > 60000 then
        error(string.format("LuaTimer:onTick frameTime %s illegal!", tostring(frameTime)))
    end

    addTask()
    removesTask()
    for key, task in pairs(TaskList) do
        task.time = task.time + frameTime
        task.tick = task.tick + 1
        if task.type == TaskType.Delay then
            if task.time >= task.delay then
                actionTask(task)
                task.time = task.time - task.delay
                LuaTimer:cancel(key)
            end
        end
        if task.type == TaskType.Period then
            while task.time >= task.period do
                actionTask(task)
                task.time = task.time - task.period
            end
        end
        if task.type == TaskType.DelayAndPeriod then
            if task.delay >= 0 then
                if task.time >= task.delay then
                    actionTask(task)
                    task.time = task.time - task.delay
                    task.delay = -1
                end
            else
                while task.time >= task.period do
                    actionTask(task)
                    task.time = task.time - task.period
                end
            end
        end
        if task.type == TaskType.PeriodTimer then
            if task.times >= 0 then
                if task.times == 0 then
                    LuaTimer:cancel(key)
                else
                    while task.time >= task.period do
                        actionTask(task)
                        task.time = task.time - task.period
                        task.times = task.times - 1
                        if task.times == 0 then
                            break
                        end
                    end
                end
            else
                while task.time >= task.period do
                    actionTask(task)
                    task.time = task.time - task.period
                end
            end
        end
        if task.type == TaskType.PeriodTicker then
            if task.times >= 0 then
                if task.times == 0 then
                    LuaTimer:cancel(key)
                else
                    while task.tick >= task.period do
                        actionTask(task)
                        task.tick = task.tick - task.period
                        task.times = task.times - 1
                        if task.times == 0 then
                            break
                        end
                    end
                end
            else
                while task.tick >= task.period do
                    actionTask(task)
                    task.tick = task.tick - task.period
                end
            end
        end
    end
end

---@param action function 回调函数
---@param delay number 延迟时间(单位:毫秒)
---@param period number 间隔时间(单位:毫秒)
---@return string 定时器唯一标示key
function LuaTimer:schedule(action, delay, period, ...)
    return LuaTimer:scheduleWithEnd(action, nil, delay, period, ...)
end

---@param action function 回调函数
---@param endAction function 结束回调函数
---@param delay number 延迟时间(单位:毫秒)
---@param period number 间隔时间(单位:毫秒)
---@return string 定时器唯一标示key
function LuaTimer:scheduleWithEnd(action, endAction, delay, period, ...)
    assert(action ~= nil, "[LuaTimer] action is nil.")
    assert(delay ~= nil or period ~= nil, "[LuaTimer] delay and period is nil.")
    ---@type LuaTimerTask
    local task = {
        action = action,
        endAction = endAction,
        type = TaskType.Undefine,
        times = 0,
        delay = 0,
        period = 0,
        params = { ... },
        tick = 0,
        time = 0,
        func_name = Lib.getCallTag()
    }
    if delay ~= nil and period == nil then
        assert(type(delay) == "number")
        task.type = TaskType.Delay
        task.delay = delay
    end
    if delay == nil and period ~= nil then
        assert(type(period) == "number")
        task.type = TaskType.Period
        task.period = period
    end
    if delay ~= nil and period ~= nil then
        assert(type(delay) == "number" and type(period) == "number")
        task.type = TaskType.DelayAndPeriod
        task.delay = delay
        task.period = period
    end

    CurTaskKey = CurTaskKey + 1
    local key = tostring(CurTaskKey)
    AddList[key] = task
    return key
end

---@param action function 回调函数
---@param period number 间隔时间(单位:毫秒)
---@param times number 回调次数
---@return string 定时器唯一标示key
function LuaTimer:scheduleTimer(action, period, times, ...)
    return LuaTimer:scheduleTimerWithEnd(action, nil, period, times, ...)
end

---@param action function 回调函数
---@param endAction function 结束回调函数
---@param period number 间隔时间(单位:毫秒)
---@param times number 回调次数
---@return string 定时器唯一标示key
function LuaTimer:scheduleTimerWithEnd(action, endAction, period, times, ...)
    assert(action ~= nil, "[LuaTimer] action is nil.")
    assert(period ~= nil, "[LuaTimer] period is nil.")
    times = times or -1
    local task = {
        action = action,
        endAction = endAction,
        type = TaskType.PeriodTimer,
        delay = 0,
        times = times,
        period = period,
        params = { ... },
        tick = 0,
        time = 0,
        func_name = Lib.getCallTag()
    }
    CurTaskKey = CurTaskKey + 1
    local key = tostring(CurTaskKey)
    AddList[key] = task
    return key
end

---@param action function 回调函数
---@param period number 间隔时间(单位:帧)
---@param times number 回调次数
---@return string 定时器唯一标示key
function LuaTimer:scheduleTicker(action, period, times, ...)
    return LuaTimer:scheduleTickerWithEnd(action, nil, period, times, ...)
end

---@param action function 回调函数
---@param endAction function 结束回调函数
---@param period number 间隔时间(单位:帧)
---@param times number 回调次数
---@return string 定时器唯一标示key
function LuaTimer:scheduleTickerWithEnd(action, endAction, period, times, ...)
    assert(action ~= nil, "[LuaTimer] action is nil.")
    assert(period ~= nil, "[LuaTimer] period is nil.")
    times = times or -1
    local task = {
        action = action,
        endAction = endAction,
        type = TaskType.PeriodTicker,
        delay = 0,
        times = times,
        period = period,
        params = { ... },
        tick = 0,
        time = 0,
        func_name = Lib.getCallTag()
    }
    CurTaskKey = CurTaskKey + 1
    local key = tostring(CurTaskKey)
    AddList[key] = task
    return key
end

function LuaTimer:resetTimer(key, delay, period, times)
    local task = TaskList[key]
    if not task then
        return
    end
    task.delay = delay or task.delay
    task.period = period or task.period
    task.times = times or task.times
end

---@param key string 定时器唯一标示key
function LuaTimer:cancel(key)
    if not key then
        return
    end
    table.insert(CancelList, key)
    if TaskList[key] and TaskList[key].endAction then
        TaskList[key].endAction()
        TaskList[key].action = function()

        end
        return
    end
    if AddList[key] and AddList[key].endAction then
        AddList[key].endAction()
        return
    end
end

function LuaTimer:getTimerTask(key)
    return TaskList[key]
end

function LuaTimer:cancelAll()
    TaskList = {}
    AddList = {}
    CancelList = {}
end

function LuaTimer:getTaskTime(key)
    if not key then
        return 0
    end
    local task = TaskList[key]
    if task then
        return task.time
    end
    return 0
end

function LuaTimer:getTaskList()
    return TaskList
end

return LuaTimer