---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by 10184.
--- DateTime: 2020/11/23 16:03
---
local LuaTimer = T(Lib, "LuaTimer") ---@type LuaTimer
local CommonActivityRewardConfig = T(Config, "CommonActivityRewardConfig") ---@type CommonActivityRewardConfig
local MustLotteryPriceConfig = T(Config, "MustLotteryPriceConfig") ---@type MustLotteryPriceConfig
local CommonActivityShowReward = T(UILib, "CommonActivityShowReward") ---@type CommonActivityShowReward
local CommonActivityRewardPreview = T(UILib, "CommonActivityRewardPreview") ---@type CommonActivityRewardPreview

local widget_panel = require "ui.widget.widget_commonActivityPanel"
local M = Lib.derive(widget_panel)

function M:init(name, activity)
    widget_panel.init(self, name, activity)
end

function M:onChildLoad()
    self.items = {}
    self.deletes = {}

    local name = self.__name:gsub(".json", "-")

    self.tvTime = self:child(name .. "Time")
    self.btnHelp = self:child(name .. "Help")
    self.llRewards = self:child(name .. "Rewards")
    self.llCenter = self:child(name .. "Center")

    ---LotteryPanel
    self.llLotteryPanel = self:child(name .. "Lottery-Panel")
    self.ivLotteryPriceIcon = self:child(name .. "Lottery-Price-Icon")
    self.tvLotteryOldPrice = self:child(name .. "Lottery-Old-Price")
    self.llLotteryOldPriceLine = self:child(name .. "Lottery-Old-Price-Line")
    self.tvLotteryNewPrice = self:child(name .. "Lottery-New-Price")
    self.llLotteryDiscountHint = self:child(name .. "Lottery-Discount-Hint")
    self.tvLotteryDiscountText = self:child(name .. "Lottery-Discount-Text")
    self.btnLottery = self:child(name .. "Lottery")
    self.tvLotteryDiscountTimes = self:child(name .. "Lottery-Discount-Times")
    ---DeletePanel
    self.llDeletePanel = self:child(name .. "Delete-Panel")
    self.tvDeleteHint = self:child(name .. "Delete-Hint")
    self.btnDelete = self:child(name .. "Delete")
    ---CenterHint
    self.tvCenterHint = self:child(name .. "Center-Hint")

    self.tvDeleteHint:SetText(string.format(Lang:getMessage("must.lottery.delete.hint"), #self.deletes))
    self.btnLottery:SetText(Lang:getMessage("common.activity.lottery"))
    self.btnDelete:SetText(Lang:getMessage("common.activity.delete"))
    self.tvCenterHint:SetText(Lang:getMessage("must.lottery.center.hint"))
    self:showCenterWindow(self.llDeletePanel)

    self:initEvent()
end

function M:initEvent()
    self:subscribe(self.btnHelp, UIEvent.EventButtonClick, function()
        UI:getWnd("commonActivityTextDialog"):showText("must.lottery.info.title", "must.lottery.info.text")
    end)

    self:subscribe(self.btnDelete, UIEvent.EventButtonClick, function()
        self:tryClickDelete()
    end)

    self:subscribe(self.btnLottery, UIEvent.EventButtonClick, function()
        self:tryClickLottery()
    end)

    Lib.subscribeEvent(Event.EventMustLotteryDelete, function(data)
        if self.activity.id ~= tonumber(data.activityId) then
            return
        end
        self:onMustLotteryDelete(data)
    end)

    Lib.subscribeEvent(Event.EventMustLotteryResult, function(data)
        if self.activity.id ~= tonumber(data.activityId) then
            return
        end
        self:onMustLotteryResult(data)
    end)

    self.wFloatReward = UIMgr:new_widget("commonActivityRewardFloat"):invoke("get")
    self:root():AddChildWindow(self.wFloatReward:root())

    Lib.subscribeEvent(Event.EventCommonActivityLayoutHide, function()
        self.wFloatReward:hide()
    end)

    Lib.subscribeEvent(Event.EventTipNeedBackPack, function(data)
        self.btnLottery:SetTouchable(true)
    end)
end

function M:showCenterWindow(window)
    self.llLotteryPanel:SetVisible(self.llLotteryPanel == window)
    self.llDeletePanel:SetVisible(self.llDeletePanel == window)
    self.tvCenterHint:SetVisible(self.tvCenterHint == window)
end

function M:onShow()
    self.wFloatReward:hide()
    if self.isInit then
        return
    end
    self.isInit = true
    local group = CommonActivityRewardConfig:getRewardGroupById(self.activity.rewardGroupId)
    if not group then
        return
    end
    local space = 8
    local row = 3
    local col = 4
    local width = (self.llRewards:GetPixelSize().x - space * (col - 1)) / col
    local height = (self.llRewards:GetPixelSize().y - space * (row - 1)) / row
    local offsetInfo = { { 0, 0 }, { 1, 0 }, { 2, 0 }, { 3, 0 }, { 3, 1 }, { 3, 2 }, { 2, 2 }, { 1, 2 }, { 0, 2 }, { 0, 1 } }
    local curIndex = 1
    for index = 1, 12 do
        local data = group[curIndex]
        if index ~= 6 and index ~= 7 and data then
            local xPos = offsetInfo[curIndex][1] * (width + space)
            local yPos = offsetInfo[curIndex][2] * (height + space)
            local item = UIMgr:new_widget("mustLotteryItem", self):invoke("get")
            item:root():SetArea({ 0, xPos }, { 0, yPos }, { 0, width }, { 0, height })
            item:onDataChanged(data)
            if self:isGetItem(item.groupSeq) then
                item:setGet()
            end
            self.llRewards:AddChildWindow(item:root())
            table.insert(self.items, item)
            curIndex = curIndex + 1
        end
    end
    self.llCenter:SetArea({ 0, 0 }, { 0, 0 }, { 0, width * 2 + space }, { 0, height })
    self:onMustLotteryDelete({ activityId = self.activity.id, deleteSeq = self.activity.deleteSeq })
    if self:isAllRewardGet() then
        self:showCenterWindow(self.tvCenterHint)
    else
        self:updatePriceUI()
    end
end

---判断是否已经完成删除操作
function M:isDeleteFinished()
    if not self.activity.deleteSeq then
        return false
    end
    local deleteCount = 0
    local deleteSeq = Lib.splitString(self.activity.deleteSeq or "", ",", true)
    for _, item in pairs(self.items) do
        if Lib.tableContain(deleteSeq, item.groupSeq) then
            deleteCount = deleteCount + 1
        end
    end
    return deleteCount >= 2
end

---判断奖励是否是被删除的
function M:isDeleteItem(groupSeq)
    local deleteSeq = Lib.splitString(self.activity.deleteSeq or "", ",")
    return Lib.tableContain(deleteSeq, tostring(groupSeq))
end

---判断奖励是否是已获得的
function M:isGetItem(groupSeq)
    local getSeq = Lib.splitString(self.activity.getSeq or "", ",")
    return Lib.tableContain(getSeq, tostring(groupSeq))
end

function M:clickItem(item)
    self.wFloatReward:showReward(item.reward, item:root())
end

function M:selectItem(item)
    if self:isDeleteFinished() then
        return
    end
    if item.isGrandPrize then
        return
    end
    if Lib.tableContain(self.deletes, item) then
        Lib.tableRemove(self.deletes, item)
        item:setSelected(false)
    else
        if #self.deletes >= 2 then
            UI:getWnd("commonActivityLayout"):showTip("must.lottery.delete.full")
            return
        end
        table.insert(self.deletes, item)
        item:setSelected(true)
    end
    self.tvDeleteHint:SetText(string.format(Lang:getMessage("must.lottery.delete.hint"), #self.deletes))
end

function M:tryClickDelete()
    if self.activity.lastTime == 0 then
        return
    end
    if self:isDeleteFinished() then
        self:showCenterWindow(self.llLotteryPanel)
        return
    end
    if #self.deletes < 2 then
        UI:getWnd("commonActivityLayout"):showTip("must.lottery.delete.less")
        return
    end
    local data = {}
    local deleteList = {}
    data.activityId = self.activity.id
    local deleteSeq = {}
    for _, delete in pairs(self.deletes) do
        table.insert(deleteSeq, delete.groupSeq)
        table.insert(deleteList, delete.reward.rewardId)
    end
    data.deleteSeq = table.concat(deleteSeq, ",")

    CommonActivityRewardPreview.builder()
                               .setCenterTip(Lang:getMessage("must.lottery.delete.sure"))
                               .setRewardView(deleteList)
                               .setSureClickListener(function()
        Me:sendPacket({ pid = "MustLotteryDelete", data = data })
    end)
                               .show()
end

function M:onMustLotteryDelete(data)
    self.activity.deleteSeq = data.deleteSeq
    if not self:isDeleteFinished() then
        self:showCenterWindow(self.llDeletePanel)
        return
    end
    for _, item in pairs(self.items) do
        item:setDelete(self:isDeleteItem(item.groupSeq))
    end
    self:showCenterWindow(self.llLotteryPanel)
    self:updatePriceUI()
end

function M:isAllRewardGet()
    local allSeq = {}
    local deleteSeq = Lib.splitString(self.activity.deleteSeq, ",", true)
    local getSeq = Lib.splitString(self.activity.getSeq, ",", true)
    Lib.mergeArray(getSeq, deleteSeq, allSeq)
    local isAllGet = true
    for _, item in pairs(self.items) do
        if not Lib.tableContain(allSeq, item.groupSeq) then
            isAllGet = false
            break
        end
    end
    return isAllGet
end

function M:tryClickLottery()
    if self.activity.lastTime == 0 then
        return
    end
    if not self:isDeleteFinished() then
        self:showCenterWindow(self.llDeletePanel)
        return
    end
    if self:isAllRewardGet() then
        self:showCenterWindow(self.tvCenterHint)
        return
    end
    local config = self:getCurrentPrice()
    if not config then
        return
    end

    if not Lib.checkMoney(Me, config.moneyType, config.discountPrice) then
        return
    end
    self.lotteryTimer = LuaTimer:schedule(function()
        self.btnLottery:SetTouchable(true)
    end, 8000)
    self:addTimer(self.lotteryTimer)
    self.btnLottery:SetTouchable(false)
    local data = {}
    data.activityId = self.activity.id
    Me:sendPacket({ pid = "MustLotteryDoLottery", data = data })
end

function M:onMustLotteryResult(data)
    LuaTimer:cancel(self.lotteryTimer)
    local function doShowResult()
        self.btnLottery:SetTouchable(true)
        for _, item in pairs(self.items) do
            if item.groupSeq == data.groupSeq then
                item:setGet()
                CommonActivityShowReward.builder()
                                        .setRewardView({ { rewardId = data.rewardId, isGrandPrize = item.isGrandPrize } })
                                        .setHideLeftButton()
                                        .setRightButton("common.activity.sure")
                                        .show()
                break
            end
        end
        if self:isAllRewardGet() then
            self:showCenterWindow(self.tvCenterHint)
        else
            self:updatePriceUI()
        end
    end
    local items = self.items
    for _, item in pairs(self.items) do
        item:setEffect(false)
        if self:isGetItem(item.groupSeq) then
            item:setGet()
        end
    end
    self.activity.getSeq = self.activity.getSeq .. "," .. data.groupSeq
    local selectPos = #items
    for pos, item in pairs(items) do
        if item.groupSeq == data.groupSeq then
            selectPos = pos
        end
    end
    local times = #items * 8 + selectPos
    local curPos = 0
    local curTimes = 0
    local period = 50
    local round = -6
    LuaTimer:cancel(self.animTimer)
    self.animTimer = LuaTimer:scheduleTimerWithEnd(function()
        curPos = curPos + 1
        curTimes = curTimes + 1
        for pos, item in pairs(items) do
            item:setEffect(pos == curPos)
        end
        if times - curTimes < 5 then
            period = period + 50
            LuaTimer:resetTimer(self.animTimer, nil, period)
        end
        if curPos >= #items then
            curPos = 0
            round = round + 1
            period = period + 25 * math.max(round, 0)
            LuaTimer:resetTimer(self.animTimer, nil, period)
        end
    end, function()
        for _, item in pairs(items) do
            item:setEffect(item.groupSeq == data.groupSeq)
        end
        self.animTimer = LuaTimer:schedule(function()
            self.animTimer = nil
            doShowResult()
            self.activity.lotteryTimes = data.lotteryTimes
        end, 1000)
        self:addTimer(self.animTimer)
    end, period, times)
    self:addTimer(self.animTimer)
end

function M:getCurrentPrice()
    local getSeq = Lib.splitString(self.activity.getSeq, ",", true)
    Lib.tableRemove(getSeq, 0)
    local config = MustLotteryPriceConfig:getPriceConfig(self.activity.priceGroupId, #getSeq + 1)
    return config
end

function M:updatePriceUI()
    local config = self:getCurrentPrice()
    if not config then
        return
    end
    self.tvLotteryOldPrice:SetText(config.price)
    self.tvLotteryDiscountTimes:SetText(Lang:getMessage(config.hintLang))
    if config.price == config.discountPrice then
        self.tvLotteryNewPrice:SetVisible(false)
        self.llLotteryDiscountHint:SetVisible(false)
        self.llLotteryOldPriceLine:SetVisible(false)
        local offset = self.tvLotteryOldPrice:GetFont():GetTextExtent(tostring(config.price), 1) + 5
        self.ivLotteryPriceIcon:SetXPosition({ 0, -offset / 2 })
    else
        self.tvLotteryNewPrice:SetVisible(true)
        self.llLotteryDiscountHint:SetVisible(true)
        self.llLotteryOldPriceLine:SetVisible(true)
        self.tvLotteryNewPrice:SetText(config.discountPrice)
        local offset = self.tvLotteryOldPrice:GetFont():GetTextExtent(tostring(config.price), 1) +
                self.tvLotteryNewPrice:GetFont():GetTextExtent(tostring(config.discountPrice), 1) + 13
        self.ivLotteryPriceIcon:SetXPosition({ 0, -offset / 2 })
        local discount = math.floor((config.price - config.discountPrice) * 100 / config.price)
        self.tvLotteryDiscountText:SetText("-" .. discount .. "%")
        self.tvLotteryNewPrice:SetVisible(true)
        self.llLotteryDiscountHint:SetVisible(true)
    end
end

function M:isNeedRedPoint()
    local isShowRed = false
    local chestGroup = CommonActivityChestConfig:getChestGroupById(self.activity.chestGroupId)
    local getChest = Lib.splitString(self.activity.getChest or "", ",")
    if chestGroup then
        for _, chest in pairs(chestGroup.chests) do
            if self.activity.lotteryTimes >= chest.times and not Lib.tableContain(getChest, chest.chestId) then
                isShowRed = true
                break
            end
        end
    end
    return isShowRed
end

return M